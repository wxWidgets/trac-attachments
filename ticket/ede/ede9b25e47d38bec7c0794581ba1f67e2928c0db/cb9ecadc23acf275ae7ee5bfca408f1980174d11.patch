changes:

wxScrollHelper (/include/wx/scrolwin.h):
	renamed m_rectToScroll to m_targetRect
	added virtual int CalcAutoScrollDelay(int autoScrollCount,
			wxCoord edgeDistance) const
	changed name of void HandleOnMouseEnter(wxMouseEvent& event) to
	   HandleOnMouseEnterTargetRect
	changed name of void HandleOnMouseLeave(wxMouseEvent& event) to
	   HandleOnMouseLeaveTargetRect
	added m_scrollTriggerRect w/ accessors
	made wxScrollHelperEvtHandler a friend


wxScrollHelper (/src/generic/scrlwing.cpp)
	renamed m_rectToScroll to m_targetRect
	changed constructor to initialization
	added m_targetRect and m_autoSetTargetRect to initialization
	added CalcAutoScrollDelay() which justs returns 50 (milliseconds)
	changed name of void HandleOnMouseLeave(wxMouseEvent& event) to
		HandleOnMouseLeaveTargetRect
	changed name of void HandleOnMouseEnter(wxMouseEvent& event) to
		HandleOnMouseEnterTargetRect
	added code to calculate parameters to send to CalcAutoScrollDelay and call
		it


wxScrollHelperEvtHandler (/src/generic/scrlwing.cpp)
	added bool m_mouseInsideTargetRect member
	changed constructor to initialization
	added m_hasDrawnWindow and m_mouseInsideTargetRect to initialization
	added initialization of wxScrollHelper::m_targetRect to ProcessEvent
		under EVT_SIZE


wxAutoScrollTimer (/src/generic/scrlwing.cpp)
	added int m_autoScrollCount member
	changed wxAutoScrollTimer constructor to initialization
	added m_autoScrollCount initialization to constructor
	changed Notify method to calculate CalcAutoScrollDelay parameters and
		call it


wxScrolledWindow docs (/docs/latex/wx/scrolwin.tex):
	added CalcAutoScrollDelay, IsAutoScrolling, SendAutoScrollEvents,
	SetTargetRect, GetTargetRect, GetTargetSize, StopAutoScrolling


--- wxWindows\docs\latex\wx\orig\scrolwin.tex	2003-06-28 22:12:59.000000000 -0400
+++ wxWindows\docs\latex\wx\scrolwin.tex	2003-06-29 03:53:32.000000000 -0400
@@ -142,4 +142,30 @@
 Destructor.
 
+\membersection{wxScrolledWindow::CalcAutoScrollDelay}\label{wxscrolledwindowcalcautoscrolldelay}
+
+\constfunc{virtual int}{CalcAutoScrollDelay}{\param{wxCoord}{ edgeDistance}, \param{int}{ autoScrollCount}}
+
+This method is used internally to set a timer which fires the next automatic scrolling
+event. It is called when a captured mouse cursor leaves the scroll trigger area, and
+also each time the timer is fired to reset the timer.  It returns the time to wait in
+milliseconds, and by default always returns 50.  This can be overridden if you want to
+create a custom delay pattern.  If this function returns an invalid interval (i.e. zero
+or less), then the automatic scroll event firing will be cancelled.
+
+\wxheading{Parameters}
+
+\docparam{autoScrollCount}{The number of autoscroll events that have occurred since the mouse left the window.}
+
+\docparam{edgeDistance}{The distance between the mouse cursor and the edge of the window.  This value is always
+positive.}
+
+\wxheading{See also}
+
+\helpref{wxScrolledWindow::GetTargetRect}{wxscrolledwindowgettargetrect}
+\helpref{wxScrolledWindow::IsAutoScrolling}{wxscrolledwindowisautoscrolling}
+\helpref{wxScrolledWindow::SendAutoScrollEvents}{wxscrolledwindowsendautoscrollevents}
+\helpref{wxScrolledWindow::SetTargetRect}{wxscrolledwindowsettargetrect}
+\helpref{wxScrolledWindow::StopAutoScrolling}{wxscrolledwindowstopautoscrolling}
+
 \membersection{wxScrolledWindow::CalcScrolledPosition}\label{wxscrolledwindowcalcscrolledposition}
 
@@ -246,4 +272,20 @@
 2-element list {\tt ( xUnit, yUnit )}.}
 
+\membersection{wxScrolledWindow::GetTargetRect}\label{wxscrolledwindowgettargetrect}
+
+\constfunc{wxRect}{GetTargetRect}{\void}
+
+Returns the coordinates of the active scroll area in the target window.
+See \helpref{wxScrolledWindow::SetTargetRect}{wxscrolledwindowsettargetrect}
+for more information.
+
+\membersection{wxScrolledWindow::GetTargetSize}\label{wxscrolledwindowgettargetsize}
+
+\constfunc{wxSize}{GetTargetSize}{\void}
+
+Returns the size of the active scroll area in the target window.
+See \helpref{wxScrolledWindow::SetTargetRect}{wxscrolledwindowsettargetrect}
+for more information.
+
 \membersection{wxScrolledWindow::GetViewStart}\label{wxscrolledwindowgetviewstart}
 
@@ -307,4 +349,18 @@
 2-element list {\tt ( x, y )}.}
 
+\membersection{wxScrolledWindow::IsAutoScrolling}\label{wxscrolledwindowisautoscrolling}
+
+\constfunc{bool}{IsAutoScrolling}{\void}
+
+Returns TRUE if autoscrolling events are being generated.
+
+\wxheading{See also}
+
+\helpref{wxScrolledWindow::CalcAutoScrollDelay}{wxscrolledwindowcalcautoscrolldelay}
+\helpref{wxScrolledWindow::GetTargetRect}{wxscrolledwindowgettargetrect}
+\helpref{wxScrolledWindow::SendAutoScrollEvents}{wxscrolledwindowsendautoscrollevents}
+\helpref{wxScrolledWindow::SetTargetRect}{wxscrolledwindowsettargetrect}
+\helpref{wxScrolledWindow::StopAutoScrolling}{wxscrolledwindowstopautoscrolling}
+
 \membersection{wxScrolledWindow::IsRetained}\label{wxscrolledwindowisretained}
 
@@ -380,4 +436,21 @@
 \helpref{wxScrolledWindow::GetScrollPixelsPerUnit}{wxscrolledwindowgetscrollpixelsperunit}
 
+\membersection{wxScrolledWindow::SendAutoScrollEvents}\label{wxscrolledwindowsendautoscrollevents}
+
+\constfunc{virtual bool}{SendAutoScrollEvents}{\param{wxScrollWinEvent\&}{ event}}
+
+This method can be overridden to filter autoscroll events. Returning FALSE
+from this method will prevent triggering of the event. The default implementation
+sends autoscroll events when the scrollbar corresponding to the event's orientation
+is active.
+
+\wxheading{See also}
+
+\helpref{wxScrolledWindow::CalcAutoScrollDelay}{wxscrolledwindowcalcautoscrolldelay}
+\helpref{wxScrolledWindow::GetTargetRect}{wxscrolledwindowgettargetrect}
+\helpref{wxScrolledWindow::IsAutoScrolling}{wxscrolledwindowisautoscrolling}
+\helpref{wxScrolledWindow::SetTargetRect}{wxscrolledwindowsettargetrect}
+\helpref{wxScrolledWindow::StopAutoScrolling}{wxscrolledwindowstopautoscrolling}
+
 \membersection{wxScrolledWindow::SetScrollbars}\label{wxscrolledwindowsetscrollbars}
 
@@ -441,4 +514,22 @@
 parameter in SetScrollbars.
 
+\membersection{wxScrolledWindow::SetTargetRect}\label{wxscrolledwindowsettargetrect}
+
+\func{void}{SetTargetRect}{\param{const wxRect\&}{ rect}}
+
+This method will restrict scrolling to only part of the target window. It also
+sets the boundaries which trigger autoscrolling when the mouse cursor leaves
+them.  By default the entire target window is scrolled.
+
+\docparam{rect}{Portion of the target window to be scrolled.}
+
+\wxheading{See also}
+
+\helpref{wxScrolledWindow::CalcAutoScrollDelay}{wxscrolledwindowcalcautoscrolldelay}
+\helpref{wxScrolledWindow::GetTargetRect}{wxscrolledwindowgettargetrect}
+\helpref{wxScrolledWindow::IsAutoScrolling}{wxscrolledwindowisautoscrolling}
+\helpref{wxScrolledWindow::SendAutoScrollEvents}{wxscrolledwindowsendautoscrollevents}
+\helpref{wxScrolledWindow::StopAutoScrolling}{wxscrolledwindowstopautoscrolling}
+
 \membersection{wxScrolledWindow::SetTargetWindow}\label{wxscrolledwindowsettargetwindow}
 
@@ -448,2 +539,16 @@
 a different window (and not on itself).
 
+\membersection{wxScrolledWindow::StopAutoScrolling}\label{wxscrolledwindowstopautoscrolling}
+
+\func{void}{StopAutoScrolling}{\void}
+
+Call this to cancel automatic generation of scrolling events.
+
+\wxheading{See also}
+
+\helpref{wxScrolledWindow::CalcAutoScrollDelay}{wxscrolledwindowcalcautoscrolldelay}
+\helpref{wxScrolledWindow::GetTargetRect}{wxscrolledwindowgettargetrect}
+\helpref{wxScrolledWindow::IsAutoScrolling}{wxscrolledwindowisautoscrolling}
+\helpref{wxScrolledWindow::SendAutoScrollEvents}{wxscrolledwindowsendautoscrollevents}
+\helpref{wxScrolledWindow::SetTargetRect}{wxscrolledwindowsettargetrect}
+
--- wxWindows-2.4.1\include\wx\orig\scrolwin.h	2003-06-28 22:13:20.000000000 -0400
+++ wxWindows-2.4.1\include\wx\scrolwin.h	2003-06-29 15:09:06.000000000 -0400
@@ -3,5 +3,5 @@
 // Purpose:     wxScrolledWindow, wxScrolledControl and wxScrollHelper
 // Author:      Vadim Zeitlin
-// Modified by:
+// Modified by: Matt Gregory 6/28/03 configurable auto scrolling
 // Created:     30.08.00
 // RCS-ID:      $Id: scrolwin.h,v 1.16 2002/06/18 12:47:40 VZ Exp $
@@ -102,6 +102,16 @@
     virtual wxWindow *GetTargetWindow() const;
 
-    void SetTargetRect(const wxRect& rect) { m_rectToScroll = rect; }
-    wxRect GetTargetRect() const { return m_rectToScroll; }
+    void SetTargetRect(const wxRect& rect) {
+        m_targetRect = rect;
+        m_autoSetTargetRect = FALSE;
+    }
+    wxRect GetTargetRect() const { return m_targetRect; }
+    // get the size of the target area
+    wxSize GetTargetSize() const { return m_targetRect.GetSize(); }
+    void GetTargetSize(int *w, int *h) {
+        wxSize size = GetTargetSize();
+        if ( w ) *w = size.x;
+        if ( h ) *h = size.y;
+    }
 
     // Override this function to draw the graphic (or just process EVT_PAINT)
@@ -114,5 +124,10 @@
     bool IsAutoScrolling() const { return m_timerAutoScroll != NULL; }
 
-    // stop generating the scroll events when mouse is held outside the window
+    // returns the number of milliseconds to wait for the next autoscroll event
+    virtual int CalcAutoScrollDelay(wxCoord edgeDistance,
+                                    int autoScrollCount) const;
+    
+    // stop generating the scroll events when mouse is held outside the
+    // target area
     void StopAutoScrolling();
 
@@ -130,6 +145,6 @@
     void HandleOnPaint(wxPaintEvent& event);
     void HandleOnChar(wxKeyEvent& event);
-    void HandleOnMouseEnter(wxMouseEvent& event);
-    void HandleOnMouseLeave(wxMouseEvent& event);
+    void HandleOnMouseEnterTargetRect(wxMouseEvent& event);
+    void HandleOnMouseLeaveTargetRect(wxMouseEvent& event);
 #if wxUSE_MOUSEWHEEL
     void HandleOnMouseWheel(wxMouseEvent& event);
@@ -145,27 +160,10 @@
 #endif // WXWIN_COMPATIBILITY_2_2
 
+    friend class wxScrollHelperEvtHandler;
 protected:
-    // get pointer to our scroll rect if we use it or NULL
-    const wxRect *GetRect() const
-    {
-        return m_rectToScroll.width != 0 ? &m_rectToScroll : NULL;
-    }
-
-    // get the size of the target window
-    wxSize GetTargetSize() const
-    {
-        return m_rectToScroll.width != 0 ? m_rectToScroll.GetSize()
-                                         : m_targetWindow->GetClientSize();
-    }
-
-    void GetTargetSize(int *w, int *h)
-    {
-        wxSize size = GetTargetSize();
-        if ( w )
-            *w = size.x;
-        if ( h )
-            *h = size.y;
-    }
-
+    // get pointer to our scroll rect
+    const wxRect *GetRect() {
+		return &m_targetRect;
+	}
     // change just the target window (unlike SetWindow which changes m_win as
     // well)
@@ -178,5 +176,10 @@
                          *m_targetWindow;
 
-    wxRect                m_rectToScroll;
+    // portion of the target window to scroll, as well as the cursor boundaries
+    // to use for autoscrolling
+    wxRect                m_targetRect;
+    // flag to indicate if the user set m_targetRect manually.  If so, don't
+    // trash his settings
+    bool                  m_autoSetTargetRect;
 
     wxTimer              *m_timerAutoScroll;
--- wxWindows-2.4.1\src\generic\orig\scrlwing.cpp	2003-06-28 22:14:23.000000000 -0400
+++ wxWindows-2.4.1\src\generic\scrlwing.cpp	2003-06-29 15:10:10.000000000 -0400
@@ -5,4 +5,5 @@
 // Modified by: Vadim Zeitlin on 31.08.00: wxScrollHelper allows to implement.
 //              Ron Lee on 10.4.02:  virtual size / auto scrollbars et al.
+//              Matt Gregory 6/28/03 configurable auto scrolling
 // Created:     01/02/97
 // RCS-ID:      $Id: scrlwing.cpp,v 1.28.2.6 2003/04/06 12:03:04 JS Exp $
@@ -71,6 +72,7 @@
 public:
     wxScrollHelperEvtHandler(wxScrollHelper *scrollHelper)
+        : m_scrollHelper(scrollHelper), m_hasDrawnWindow(FALSE),
+        m_mouseInsideTargetRect(FALSE)
     {
-        m_scrollHelper = scrollHelper;
     }
 
@@ -83,4 +85,5 @@
 
     bool m_hasDrawnWindow;
+    bool m_mouseInsideTargetRect;
 };
 
@@ -105,4 +108,5 @@
     int m_pos,
         m_orient;
+    int m_autoScrollCount;
 };
 
@@ -119,22 +123,19 @@
                                      wxEventType eventTypeToSend,
                                      int pos, int orient)
+    : m_win(winToScroll),
+    m_scrollHelper(scroll),
+    m_eventType(eventTypeToSend),
+    m_pos(pos),
+    m_orient(orient),
+    m_autoScrollCount(0)
 {
-    m_win = winToScroll;
-    m_scrollHelper = scroll;
-    m_eventType = eventTypeToSend;
-    m_pos = pos;
-    m_orient = orient;
 }
 
 void wxAutoScrollTimer::Notify()
 {
-    // only do all this as long as the window is capturing the mouse
-    if ( wxWindow::GetCapture() != m_win )
+    // if mouse is still captured, continue generating events
+    if ( wxWindow::GetCapture() == m_win )
     {
-        Stop();
-    }
-    else // we still capture the mouse, continue generating events
-    {
-        // first scroll the window if we are allowed to do it
+        // scroll the window if we are allowed to do it
         wxScrollWinEvent event1(m_eventType, m_pos, m_orient);
         event1.SetEventObject(m_win);
@@ -142,28 +143,47 @@
                 m_win->GetEventHandler()->ProcessEvent(event1) )
         {
-            // and then send a pseudo mouse-move event to refresh the selection
-            wxMouseEvent event2(wxEVT_MOTION);
-            wxGetMousePosition(&event2.m_x, &event2.m_y);
+            // retrieve the mouse position
+            int mx, my;
+            wxGetMousePosition(&mx, &my);
 
             // the mouse event coordinates should be client, not screen as
             // returned by wxGetMousePosition
-            wxWindow *parentTop = m_win;
-            while ( parentTop->GetParent() )
-                parentTop = parentTop->GetParent();
-            wxPoint ptOrig = parentTop->GetPosition();
-            event2.m_x -= ptOrig.x;
-            event2.m_y -= ptOrig.y;
+            m_scrollHelper->GetTargetWindow()->ScreenToClient(&mx, &my);
 
+            // find distance between cursor and edge of target area
+            wxCoord edgeDistance = 0;
+            wxRect tRect = m_scrollHelper->GetTargetRect();
+            if ( mx < tRect.GetLeft() ) {
+                edgeDistance = tRect.GetLeft() - mx;
+            } else if ( my < tRect.GetTop() ) {
+                edgeDistance = tRect.GetTop() - my;
+            } else if ( mx > tRect.GetRight() ) {
+                edgeDistance = mx - tRect.GetRight();
+            } else if ( my > tRect.GetBottom() ) {
+                edgeDistance = my - tRect.GetBottom();
+            }
+            // send a pseudo mouse-move event to refresh the selection
+            wxMouseEvent event2(wxEVT_MOTION);
             event2.SetEventObject(m_win);
+            event2.m_x = mx;
+            event2.m_y = my;
 
             // FIXME: we don't fill in the other members - ok?
 
             m_win->GetEventHandler()->ProcessEvent(event2);
-        }
-        else // can't scroll further, stop
-        {
-            Stop();
+
+            // reset the timer for the next autoscroll event
+            int timerDelay = m_scrollHelper->CalcAutoScrollDelay(edgeDistance,
+                    ++m_autoScrollCount );
+            // only scroll if CalcAutoScrollDelay() returns a valid interval
+            if (timerDelay > 0) {
+                const bool oneShot = TRUE;
+                Start( timerDelay, oneShot );
+                return;
+            }
         }
     }
+    // reset the count (time user has held cursor outside target area)
+    m_autoScrollCount = 0;
 }
 
@@ -208,4 +228,8 @@
         m_scrollHelper->HandleOnSize((wxSizeEvent &)event);
 
+        // m_targetRect must be set in wxScrollHelper
+        m_scrollHelper->m_targetRect =
+            m_scrollHelper->m_targetWindow->GetClientRect();
+
         return TRUE;
     }
@@ -245,11 +269,20 @@
     }
 
-    if ( evType == wxEVT_ENTER_WINDOW )
-    {
-        m_scrollHelper->HandleOnMouseEnter((wxMouseEvent &)event);
-    }
-    else if ( evType == wxEVT_LEAVE_WINDOW )
-    {
-        m_scrollHelper->HandleOnMouseLeave((wxMouseEvent &)event);
+    if ( evType == wxEVT_MOTION ||
+         evType == wxEVT_ENTER_WINDOW ||
+         evType == wxEVT_LEAVE_WINDOW )
+    {
+        wxMouseEvent& mouseEvent = (wxMouseEvent&) event;
+        // handle enter/leave target rect situations
+        wxRect tRect = m_scrollHelper->GetTargetRect();
+        bool mouseNowInsideTargetRect = tRect.Inside(mouseEvent.GetPosition());
+
+        if (!m_mouseInsideTargetRect && mouseNowInsideTargetRect) {
+            m_scrollHelper->HandleOnMouseEnterTargetRect(mouseEvent);
+        } else if (m_mouseInsideTargetRect && !mouseNowInsideTargetRect) {
+            m_scrollHelper->HandleOnMouseLeaveTargetRect(mouseEvent);
+        }
+        m_mouseInsideTargetRect = mouseNowInsideTargetRect;
+        return !event.GetSkipped();
     }
 #if wxUSE_MOUSEWHEEL
@@ -273,30 +306,26 @@
 
 wxScrollHelper::wxScrollHelper(wxWindow *win)
-{
-    m_xScrollPixelsPerLine =
-    m_yScrollPixelsPerLine =
-    m_xScrollPosition =
-    m_yScrollPosition =
-    m_xScrollLines =
-    m_yScrollLines =
-    m_xScrollLinesPerPage =
-    m_yScrollLinesPerPage = 0;
-
-    m_xScrollingEnabled =
-    m_yScrollingEnabled = TRUE;
-
-    m_scaleX =
-    m_scaleY = 1.0;
+    : m_xScrollPixelsPerLine(0),
+    m_yScrollPixelsPerLine(0),
+    m_xScrollPosition(0),
+    m_yScrollPosition(0),
+    m_xScrollLines(0),
+    m_yScrollLines(0),
+    m_xScrollLinesPerPage(0),
+    m_yScrollLinesPerPage(0),
+    m_xScrollingEnabled(TRUE),
+    m_yScrollingEnabled(TRUE),
+    m_scaleX(1.0),
+    m_scaleY(1.0),
 #if wxUSE_MOUSEWHEEL
-    m_wheelRotation = 0;
+    m_wheelRotation(0),
 #endif
-
-    m_win =
-    m_targetWindow = (wxWindow *)NULL;
-
-    m_timerAutoScroll = (wxTimer *)NULL;
-
-    m_handler = NULL;
-
+    m_win((wxWindow*) NULL),
+    m_targetWindow((wxWindow*) NULL),
+    m_targetRect(0, 0, 0, 0),
+    m_autoSetTargetRect(TRUE),
+    m_timerAutoScroll((wxTimer *)NULL),
+    m_handler(NULL)
+{
     if ( win )
         SetWindow(win);
@@ -348,5 +377,4 @@
     int h = noUnitsY * pixelsPerUnitY;
      
-    wxSize sz = m_targetWindow->GetClientSize();
     m_targetWindow->SetVirtualSizeHints( w, h );
 
@@ -1016,4 +1044,10 @@
 // ----------------------------------------------------------------------------
 
+int wxScrollHelper::CalcAutoScrollDelay(wxCoord edgeDistance,
+                                        int autoScrollCount) const
+{
+    return 50; // default timer delay
+}
+
 bool wxScrollHelper::SendAutoScrollEvents(wxScrollWinEvent& event) const
 {
@@ -1032,5 +1066,5 @@
 }
 
-void wxScrollHelper::HandleOnMouseEnter(wxMouseEvent& event)
+void wxScrollHelper::HandleOnMouseEnterTargetRect(wxMouseEvent& event)
 {
     StopAutoScrolling();
@@ -1039,5 +1073,5 @@
 }
 
-void wxScrollHelper::HandleOnMouseLeave(wxMouseEvent& event)
+void wxScrollHelper::HandleOnMouseLeaveTargetRect(wxMouseEvent& event)
 {
     // don't prevent the usual processing of the event from taking place
@@ -1049,29 +1083,37 @@
     if ( wxWindow::GetCapture() == m_targetWindow )
     {
+        wxRect tRect = GetTargetRect();
+
         // where is the mouse leaving?
         int pos, orient;
+        // the distance from the cursor to the edge of the window
+        int edgeDistance = 0;
+
         wxPoint pt = event.GetPosition();
-        if ( pt.x < 0 )
+        if ( pt.x < tRect.GetLeft() )
         {
             orient = wxHORIZONTAL;
             pos = 0;
+            edgeDistance = pt.x - tRect.GetLeft();
         }
-        else if ( pt.y < 0 )
+        else if ( pt.y < tRect.GetTop() )
         {
             orient = wxVERTICAL;
             pos = 0;
+            edgeDistance = pt.y - tRect.GetTop();
         }
         else // we're lower or to the right of the window
         {
-            wxSize size = m_targetWindow->GetClientSize();
-            if ( pt.x > size.x )
+            if ( pt.x > tRect.GetRight() )
             {
                 orient = wxHORIZONTAL;
                 pos = m_xScrollLines;
+                edgeDistance = pt.x - tRect.GetRight();
             }
-            else if ( pt.y > size.y )
+            else if ( pt.y > tRect.GetBottom() )
             {
                 orient = wxVERTICAL;
                 pos = m_yScrollLines;
+                edgeDistance = pt.y - tRect.GetBottom();
             }
             else // this should be impossible
@@ -1100,5 +1142,11 @@
                                     orient
                                 );
-        m_timerAutoScroll->Start(50); // FIXME: make configurable
+        // calculate delay with a count of 0, since this is the first
+        //   of a presumed batch of autoscroll events
+        int timerDelay = CalcAutoScrollDelay( edgeDistance, 0 );
+        // set timer only if a valid interval has been returned
+        if (timerDelay > 0) {
+            m_timerAutoScroll->Start( timerDelay, TRUE );
+        }
     }
 }
--- wxWindows-2.4.1\samples\scroll\orig\scroll.cpp	2003-06-27 15:28:41.000000000 -0400
+++ wxWindows-2.4.1\samples\scroll\scroll.cpp	2003-06-29 03:40:33.000000000 -0400
@@ -6,4 +6,5 @@
  * Copyright: (C) 1998, Robert Roebling
  *                2002, Ron Lee
+ *                2003, Matt Gregory
  *
  */
@@ -135,4 +136,67 @@
 };
 
+// ----------------------------------------------------------------------------
+// MyAutoTimedScrollingWindow: implements a text viewer with simple blocksize
+//                             selection to test auto-scrolling functionality
+// ----------------------------------------------------------------------------
+
+class MyAutoTimedScrollingWindow : public wxScrolledWindow
+{
+public: // interface
+
+    enum TimingAlgorithm {
+        FLAT,
+        TIME,
+        DISTANCE
+    };
+
+    // creators
+    MyAutoTimedScrollingWindow( wxWindow* parent );
+
+    // modifiers
+    void SetTimingAlgorithm(TimingAlgorithm algorithm) {
+        m_timingAlgorithm = algorithm;
+    }
+    // accessors
+    wxRect DeviceCoordsToGraphicalChars(wxRect updRect) const;
+    wxPoint DeviceCoordsToGraphicalChars(wxPoint pos) const;
+    wxPoint GraphicalCharToDeviceCoords(wxPoint pos) const;
+    wxRect LogicalCoordsToGraphicalChars(wxRect updRect) const;
+    wxPoint LogicalCoordsToGraphicalChars(wxPoint pos) const;
+    wxPoint GraphicalCharToLogicalCoords(wxPoint pos) const;
+    bool IsSelected(int chX, int chY) const;
+
+    // static utility methods
+    static bool IsInside(int k, int bound1, int bound2);
+    static wxRect DCNormalize(wxCoord x, wxCoord y, wxCoord w, wxCoord h);
+
+protected:  // implementation
+    void MyRefresh();
+
+protected: // event stuff
+    DECLARE_EVENT_TABLE()
+    void OnDraw(wxDC& dc);
+    void OnMouseLeftDown(wxMouseEvent& event);
+    void OnMouseLeftUp(wxMouseEvent& event);
+    void OnMouseMove(wxMouseEvent& event);
+    void OnScroll(wxScrollWinEvent& event);
+
+protected:  // member data
+    // sizes for graphical data
+    wxCoord m_fontH, m_fontW;
+    // selection tracking
+    wxPoint m_selStart; // beginning of blockwise selection
+    wxPoint m_cursor;   // end of blockwise selection (mouse position)
+    TimingAlgorithm m_timingAlgorithm;
+    // delay pattern generator
+    virtual int CalcAutoScrollDelay(wxCoord edgeDistance
+            , int autoScrollCount) const;
+    // test data variables
+    static const wxChar* sm_testData;
+    static const int sm_lineCnt; // line count
+    static const int sm_lineLen; // line length in characters
+protected:  // gui stuff
+    wxFont m_font;
+};
 
 // ----------------------------------------------------------------------------
@@ -149,7 +213,11 @@
     void OnDeleteAll( wxCommandEvent &event );
     void OnInsertNew( wxCommandEvent &event );
+    void OnFlatDelay( wxCommandEvent &event );
+    void OnTimeDelay( wxCommandEvent &event );
+    void OnDistanceDelay( wxCommandEvent &event );
 
     MyCanvas         *m_canvas;
     wxTextCtrl       *m_log;
+    MyAutoTimedScrollingWindow *m_autoTimedWin;
 
     DECLARE_DYNAMIC_CLASS(MyFrame)
@@ -157,5 +225,7 @@
 };
 
+// ----------------------------------------------------------------------------
 // MyApp
+// ----------------------------------------------------------------------------
 
 class MyApp: public wxApp
@@ -165,5 +235,8 @@
 };
 
+
+// ----------------------------------------------------------------------------
 // main program
+// ----------------------------------------------------------------------------
 
 IMPLEMENT_APP(MyApp)
@@ -179,5 +252,7 @@
 const long   ID_NEWBUTTON   = wxNewId();
 
+// ----------------------------------------------------------------------------
 // MyCanvas
+// ----------------------------------------------------------------------------
 
 IMPLEMENT_DYNAMIC_CLASS(MyCanvas, wxScrolledWindow)
@@ -348,5 +423,7 @@
 }
 
+// ----------------------------------------------------------------------------
 // MyAutoScrollWindow
+// ----------------------------------------------------------------------------
 
 const long   ID_RESIZEBUTTON = wxNewId();
@@ -423,10 +500,15 @@
 }
 
+// ----------------------------------------------------------------------------
 // MyFrame
+// ----------------------------------------------------------------------------
 
-const long ID_QUIT       = wxNewId();
-const long ID_ABOUT      = wxNewId();
-const long ID_DELETE_ALL = wxNewId();
-const long ID_INSERT_NEW = wxNewId();
+const long ID_QUIT           = wxNewId();
+const long ID_ABOUT          = wxNewId();
+const long ID_DELETE_ALL     = wxNewId();
+const long ID_INSERT_NEW     = wxNewId();
+const long ID_FLAT_DELAY     = wxNewId();
+const long ID_TIME_DELAY     = wxNewId();
+const long ID_DISTANCE_DELAY = wxNewId();
 
 IMPLEMENT_DYNAMIC_CLASS( MyFrame, wxFrame )
@@ -437,9 +519,12 @@
   EVT_MENU    (ID_ABOUT, MyFrame::OnAbout)
   EVT_MENU    (ID_QUIT,  MyFrame::OnQuit)
+  EVT_MENU    (ID_FLAT_DELAY, MyFrame::OnFlatDelay)
+  EVT_MENU    (ID_TIME_DELAY, MyFrame::OnTimeDelay)
+  EVT_MENU    (ID_DISTANCE_DELAY, MyFrame::OnDistanceDelay)
 END_EVENT_TABLE()
 
 MyFrame::MyFrame()
        : wxFrame( (wxFrame *)NULL, -1, _T("wxScrolledWindow sample"),
-                  wxPoint(20,20), wxSize(470,500) )
+                  wxPoint(20,20), wxSize(800,500) )
 {
     wxMenu *file_menu = new wxMenu();
@@ -449,6 +534,17 @@
     file_menu->Append( ID_QUIT,       _T("E&xit\tAlt-X"));
 
+    wxMenu *timed_menu = new wxMenu();
+    timed_menu->Append( ID_FLAT_DELAY, _T("Flat 50 ms delay"),
+            wxEmptyString, wxITEM_RADIO);
+    timed_menu->Append( ID_TIME_DELAY,
+            _T("Delay inversely proportional to time outside window"),
+            wxEmptyString, wxITEM_RADIO);
+    timed_menu->Append( ID_DISTANCE_DELAY,
+            _T("Delay inversely proportional to cursor distance"),
+            wxEmptyString, wxITEM_RADIO);
+
     wxMenuBar *menu_bar = new wxMenuBar();
     menu_bar->Append(file_menu, _T("&File"));
+    menu_bar->Append(timed_menu, _T("&Text window scroll delay algorithm"));
 
     SetMenuBar( menu_bar );
@@ -458,21 +554,27 @@
     SetStatusWidths( 2, widths );
 
-    wxBoxSizer *topsizer = new wxBoxSizer( wxVERTICAL );
+    wxBoxSizer *topsizer = new wxBoxSizer( wxHORIZONTAL );
+    // subsizer splits topsizer down the middle
+    wxBoxSizer *subsizer = new wxBoxSizer( wxVERTICAL );
 
     // Setting an explicit size here is superfluous, it will be overridden
     // by the sizer in any case.
     m_canvas = new MyCanvas( this, -1, wxPoint(0,0), wxSize(100,100) );
-
+    
     // This is done with ScrollRate/VirtualSize in MyCanvas ctor now,
     // both should produce identical results.
     //m_canvas->SetScrollbars( 10, 10, 50, 100 );
 
-    topsizer->Add( m_canvas, 1, wxEXPAND );
-    topsizer->Add( new MyAutoScrollWindow( this ), 1, wxEXPAND );
+    subsizer->Add( m_canvas, 1, wxEXPAND );
+    subsizer->Add( new MyAutoScrollWindow( this ), 1, wxEXPAND );
 
     wxSizer *sizerBtm = new wxBoxSizer(wxHORIZONTAL);
     sizerBtm->Add( new MyScrolledWindowDumb(this), 1, wxEXPAND );
     sizerBtm->Add( new MyScrolledWindowSmart(this), 1, wxEXPAND );
-    topsizer->Add( sizerBtm, 1, wxEXPAND );
+    subsizer->Add( sizerBtm, 1, wxEXPAND );
+
+    topsizer->Add( subsizer, 1, wxEXPAND );
+    m_autoTimedWin = new MyAutoTimedScrollingWindow( this );
+    topsizer->Add( m_autoTimedWin, 1, wxEXPAND );
 
     SetSizer( topsizer );
@@ -496,12 +598,29 @@
 void MyFrame::OnAbout( wxCommandEvent &WXUNUSED(event) )
 {
-  (void)wxMessageBox( _T("wxScroll demo\n"
-                         "Robert Roebling (c) 1998\n"
-                         "Autoscrolling examples\n"
-                         "Ron Lee (c) 2002"),
+  (void)wxMessageBox( _T("wxScroll demo\n")
+                      _T("Robert Roebling (c) 1998\n")
+                      _T("Autoscrolling examples\n")
+                      _T("Ron Lee (c) 2002\n")
+                      _T("Auto-timed-scrolling example\n")
+                      _T("Matt Gregory (c) 2003\n"),
                       _T("About wxScroll Demo"),
                       wxICON_INFORMATION | wxOK );
 }
 
+void MyFrame::OnFlatDelay( wxCommandEvent &event )
+{
+    m_autoTimedWin->SetTimingAlgorithm( MyAutoTimedScrollingWindow::FLAT );
+}
+
+void MyFrame::OnTimeDelay( wxCommandEvent &event )
+{
+    m_autoTimedWin->SetTimingAlgorithm( MyAutoTimedScrollingWindow::TIME );
+}
+
+void MyFrame::OnDistanceDelay( wxCommandEvent &event )
+{
+    m_autoTimedWin->SetTimingAlgorithm( MyAutoTimedScrollingWindow::DISTANCE );
+}
+
 //-----------------------------------------------------------------------------
 // MyApp
@@ -566,2 +685,482 @@
     }
 }
+
+// ----------------------------------------------------------------------------
+// MyAutoTimedScrollingWindow
+// ----------------------------------------------------------------------------
+
+BEGIN_EVENT_TABLE(MyAutoTimedScrollingWindow, wxScrolledWindow)
+    EVT_LEFT_DOWN(OnMouseLeftDown)
+    EVT_LEFT_UP(OnMouseLeftUp)
+    EVT_MOTION(OnMouseMove)
+    EVT_SCROLLWIN(OnScroll)
+END_EVENT_TABLE()
+
+MyAutoTimedScrollingWindow::MyAutoTimedScrollingWindow(wxWindow* parent)
+    : wxScrolledWindow(parent, -1, wxDefaultPosition, wxDefaultSize
+            //, wxSUNKEN_BORDER) // can't seem to do it this way
+            , wxVSCROLL | wxHSCROLL | wxSUNKEN_BORDER)
+    , m_selStart(-1, -1), m_cursor(-1, -1)
+    , m_font(9, wxFONTFAMILY_TELETYPE, wxFONTSTYLE_NORMAL
+            , wxFONTWEIGHT_NORMAL)
+    , m_timingAlgorithm(FLAT)
+{
+    // query dc for text size
+    wxClientDC dc(this);
+    dc.SetFont(m_font);
+    // fixed width font, so one character will do
+    dc.GetTextExtent(wxString(_T("A")), &m_fontW, &m_fontH);
+    // set up the virtual window
+    SetScrollbars(m_fontW, m_fontH, sm_lineLen, sm_lineCnt);
+}
+
+int MyAutoTimedScrollingWindow::CalcAutoScrollDelay(wxCoord edgeDistance
+        , int autoScrollCount) const
+{
+    // speed limit 25
+    int delay = 25;
+    switch (m_timingAlgorithm) {
+    case FLAT:
+        delay = 50;
+        break;
+    case TIME:
+        // the longer the user holds the cursor outside the window, the
+        // faster it will scroll
+        if (autoScrollCount < 4) {
+            delay = 250;
+        } else if (autoScrollCount < 9) {
+            delay = 200;
+        } else if (autoScrollCount < 16) {
+            delay = 150;
+        } else if (autoScrollCount < 26) {
+            delay = 100;
+        } else if (autoScrollCount < 46) {
+            delay = 50;
+        }
+        break;
+    case DISTANCE:
+        // the farther the user moves the cursor from the window, the
+        // faster it will scroll
+        if (edgeDistance < 15) {
+            delay = 250;
+        } else if (edgeDistance < 30) {
+            delay = 200;
+        } else if (edgeDistance < 45) {
+            delay = 150;
+        } else if (edgeDistance < 60) {
+            delay = 100;
+        } else if (edgeDistance < 75) {
+            delay = 50;
+        }
+        break;
+    }
+    return delay;
+}
+
+wxRect MyAutoTimedScrollingWindow::DCNormalize(wxCoord x, wxCoord y
+        , wxCoord w, wxCoord h)
+{
+    // this is needed to get rid of the graphical remnants from the selection
+    // I think it's because DrawRectangle() excludes a pixel in either direction
+    const int kludge = 1;
+    // make (x, y) the top-left corner
+    if (w < 0) {
+        w = -w + kludge;
+        x -= w;
+    } else {
+        x -= kludge;
+        w += kludge;
+    }
+    if (h < 0) {
+        h = -h + kludge;
+        y -= h;
+    } else {
+        y -= kludge;
+        h += kludge;
+    }
+    return wxRect(x, y, w, h);
+}
+
+wxRect MyAutoTimedScrollingWindow::DeviceCoordsToGraphicalChars
+        (wxRect updRect) const
+{
+    wxPoint pos(updRect.GetPosition());
+    pos = DeviceCoordsToGraphicalChars(pos);
+    updRect.x = pos.x;
+    updRect.y = pos.y;
+    updRect.width /= m_fontW;
+    updRect.height /= m_fontH;
+    // the *CoordsToGraphicalChars() funcs round down to upper-left corner,
+    //   so an off-by-one correction is needed
+    ++updRect.width; // kludge
+    ++updRect.height; // kludge
+    return updRect;
+}
+
+wxPoint MyAutoTimedScrollingWindow::DeviceCoordsToGraphicalChars
+        (wxPoint pos) const
+{
+    pos.x /= m_fontW;
+    pos.y /= m_fontH;
+    int vX, vY;
+    GetViewStart(&vX, &vY);
+    pos.x += vX;
+    pos.y += vY;
+    return pos;
+}
+
+wxPoint MyAutoTimedScrollingWindow::GraphicalCharToDeviceCoords
+        (wxPoint pos) const
+{
+    int vX, vY;
+    GetViewStart(&vX, &vY);
+    pos.x -= vX;
+    pos.y -= vY;
+    pos.x *= m_fontW;
+    pos.y *= m_fontH;
+    return pos;
+}
+
+wxPoint MyAutoTimedScrollingWindow::GraphicalCharToLogicalCoords
+        (wxPoint pos) const
+{
+    pos.x *= m_fontW;
+    pos.y *= m_fontH;
+    return pos;
+}
+
+bool MyAutoTimedScrollingWindow::IsInside(int k, int bound1, int bound2)
+{
+    if ((k >= bound1 && k <= bound2) || (k >= bound2 && k <= bound1)) {
+        return TRUE;
+    }
+    return FALSE;
+}
+
+bool MyAutoTimedScrollingWindow::IsSelected(int chX, int chY) const
+{
+    if (IsInside(chX, m_selStart.x, m_cursor.x)
+            && IsInside(chY, m_selStart.y, m_cursor.y)) {
+        return TRUE;
+    }
+    return FALSE;
+}
+
+wxRect MyAutoTimedScrollingWindow::LogicalCoordsToGraphicalChars
+        (wxRect updRect) const
+{
+    wxPoint pos(updRect.GetPosition());
+    pos = LogicalCoordsToGraphicalChars(pos);
+    updRect.x = pos.x;
+    updRect.y = pos.y;
+    updRect.width /= m_fontW;
+    updRect.height /= m_fontH;
+    // the *CoordsToGraphicalChars() funcs round down to upper-left corner,
+    //   so an off-by-one correction is needed
+    ++updRect.width; // kludge
+    ++updRect.height; // kludge
+    return updRect;
+}
+
+wxPoint MyAutoTimedScrollingWindow::LogicalCoordsToGraphicalChars
+        (wxPoint pos) const
+{
+    pos.x /= m_fontW;
+    pos.y /= m_fontH;
+    return pos;
+}
+
+void MyAutoTimedScrollingWindow::MyRefresh()
+{
+    static wxPoint lastSelStart(-1, -1), lastCursor(-1, -1);
+    // refresh last selected area (to deselect previously selected text)
+    wxRect lastUpdRect(
+            GraphicalCharToDeviceCoords(lastSelStart),
+            GraphicalCharToDeviceCoords(lastCursor)
+        );
+    // off-by-one corrections, necessary because it's not possible to know
+    //   when to round up until rect is normalized by lastUpdRect constructor
+    lastUpdRect.width += m_fontW; // kludge
+    lastUpdRect.height += m_fontH; // kludge
+    // refresh currently selected (to select previously unselected text)
+    wxRect updRect(
+            GraphicalCharToDeviceCoords(m_selStart),
+            GraphicalCharToDeviceCoords(m_cursor)
+        );
+    // off-by-one corrections
+    updRect.width += m_fontW; // kludge
+    updRect.height += m_fontH; // kludge
+    // find necessary refresh areas
+    wxCoord rx = lastUpdRect.x;
+    wxCoord ry = lastUpdRect.y;
+    wxCoord rw = updRect.x - lastUpdRect.x;
+    wxCoord rh = lastUpdRect.height;
+    if (rw && rh) {
+        RefreshRect(DCNormalize(rx, ry, rw, rh));
+    }
+    rx = updRect.x;
+    ry = updRect.y + updRect.height;
+    rw= updRect.width;
+    rh = (lastUpdRect.y + lastUpdRect.height) - (updRect.y + updRect.height);
+    if (rw && rh) {
+        RefreshRect(DCNormalize(rx, ry, rw, rh));
+    }
+    rx = updRect.x + updRect.width;
+    ry = lastUpdRect.y;
+    rw = (lastUpdRect.x + lastUpdRect.width) - (updRect.x + updRect.width);
+    rh = lastUpdRect.height;
+    if (rw && rh) {
+        RefreshRect(DCNormalize(rx, ry, rw, rh));
+    }
+    rx = updRect.x;
+    ry = lastUpdRect.y;
+    rw = updRect.width;
+    rh = updRect.y - lastUpdRect.y;
+    if (rw && rh) {
+        RefreshRect(DCNormalize(rx, ry, rw, rh));
+    }
+    // update last
+    lastSelStart = m_selStart;
+    lastCursor = m_cursor;
+}
+
+void MyAutoTimedScrollingWindow::OnDraw(wxDC& dc)
+{
+    // set up some dc trinkets
+    dc.SetFont(m_font);
+    wxBrush normBrush(wxSystemSettings::GetColour(wxSYS_COLOUR_WINDOW)
+            , wxSOLID);
+    wxBrush selBrush(wxSystemSettings::GetColour(wxSYS_COLOUR_HIGHLIGHT)
+            , wxSOLID);
+    dc.SetPen(*wxTRANSPARENT_PEN);
+    // draw the characters
+    // 1. for each update region
+    for (wxRegionIterator upd(GetUpdateRegion()); upd; ++upd) {
+        wxSize clientSize = GetClientSize();
+        wxRect updRect = upd.GetRect();
+        wxRect updRectInGChars(DeviceCoordsToGraphicalChars(updRect));
+        // 2. for each row of chars in the update region
+        for (int chY = updRectInGChars.y
+                ; chY <= updRectInGChars.y + updRectInGChars.height; ++chY) {
+            // 3. for each character in the row
+            for (int chX = updRectInGChars.x
+                    ; chX <= updRectInGChars.x + updRectInGChars.width
+                    ; ++chX) {
+                // 4. set the text colors (selected/not)
+                if (IsSelected(chX, chY)) {
+                    dc.SetBrush(selBrush);
+                    dc.SetTextForeground( wxSystemSettings::GetColour
+                            (wxSYS_COLOUR_HIGHLIGHTTEXT));
+                } else {
+                    dc.SetBrush(normBrush);
+                    dc.SetTextForeground( wxSystemSettings::GetColour
+                            (wxSYS_COLOUR_WINDOWTEXT));
+                }
+                // 5. find position info
+                wxPoint charPos = GraphicalCharToLogicalCoords(wxPoint
+                        (chX, chY));
+                // 6. draw!
+                dc.DrawRectangle(charPos.x, charPos.y, m_fontW, m_fontH);
+                if (chY < sm_lineCnt && chX < sm_lineLen) {
+                    int charIndex = chY * sm_lineLen + chX;
+                    dc.DrawText(wxString(sm_testData[charIndex])
+                            , charPos.x, charPos.y);
+                }
+            }
+        }
+    }
+}
+
+void MyAutoTimedScrollingWindow::OnMouseLeftDown(wxMouseEvent& event)
+{
+    // initial press of mouse button sets the beginning of the selection
+    m_selStart = DeviceCoordsToGraphicalChars(event.GetPosition());
+    // set the cursor to the same position
+    m_cursor = m_selStart;
+    // draw/erase selection
+    MyRefresh();
+}
+
+void MyAutoTimedScrollingWindow::OnMouseLeftUp(wxMouseEvent& event)
+{
+    // this test is necessary
+    if (HasCapture()) {
+        // uncapture mouse
+        ReleaseMouse();
+    }
+}
+
+void MyAutoTimedScrollingWindow::OnMouseMove(wxMouseEvent& event)
+{
+    // if user is dragging
+    if (event.Dragging() && event.LeftIsDown()) {
+        // set the new cursor position
+        m_cursor = DeviceCoordsToGraphicalChars(event.GetPosition());
+        // draw/erase selection
+        MyRefresh();
+        // capture mouse to activate auto-scrolling
+        if (!HasCapture()) {
+            CaptureMouse();
+        }
+    }
+    event.Skip();
+}
+
+void MyAutoTimedScrollingWindow::OnScroll(wxScrollWinEvent& event)
+{
+    // need to move the cursor when autoscrolling
+    if (IsAutoScrolling()) {
+        if (event.GetOrientation() == wxHORIZONTAL) {
+            if (event.m_eventType == wxEVT_SCROLLWIN_LINEUP) {
+                --m_cursor.x;
+            } else if (event.m_eventType == wxEVT_SCROLLWIN_LINEDOWN) {
+                ++m_cursor.x;
+            }
+        } else if (event.GetOrientation() == wxVERTICAL) {
+            if (event.m_eventType == wxEVT_SCROLLWIN_LINEUP) {
+                --m_cursor.y;
+            } else if (event.m_eventType == wxEVT_SCROLLWIN_LINEDOWN) {
+                ++m_cursor.y;
+            }
+        }
+    }
+    MyRefresh();
+    event.Skip();
+}
+
+// shhhh...I sneakily made all the lines the same length so I won't have to
+// check each line later! ROFL
+const int MyAutoTimedScrollingWindow::sm_lineLen = 79;
+const int MyAutoTimedScrollingWindow::sm_lineCnt = 125;
+const wxChar* MyAutoTimedScrollingWindow::sm_testData = _T("\
+162 Cult of the genius out of vanity.— Because we think well of ourselves, but \
+nonetheless never suppose ourselves capable of producing a painting like one of\
+Raphael's or a dramatic scene like one of Shakespeare's, we convince ourselves \
+that the capacity to do so is quite extraordinarily marvelous, a wholly        \
+uncommon accident, or, if we are still religiously inclined, a mercy from on   \
+high. Thus our vanity, our self-love, promotes the cult of the genius: for only\
+if we think of him as being very remote from us, as a miraculum, does he not   \
+aggrieve us (even Goethe, who was without envy, called Shakespeare his star of \
+the most distant heights [\"William! Stern der schönsten Ferne\": from Goethe's, \
+\"Between Two Worlds\"]; in regard to which one might recall the lines: \"the     \
+stars, these we do not desire\" [from Goethe's, \"Comfort in Tears\"]). But, aside\
+from these suggestions of our vanity, the activity of the genius seems in no   \
+way fundamentally different from the activity of the inventor of machines, the \
+scholar of astronomy or history, the master of tactics. All these activities   \
+are explicable if one pictures to oneself people whose thinking is active in   \
+one direction, who employ everything as material, who always zealously observe \
+their own inner life and that of others, who perceive everywhere models and    \
+incentives, who never tire of combining together the means available to them.  \
+Genius too does nothing except learn first how to lay bricks then how to build,\
+except continually seek for material and continually form itself around it.    \
+Every activity of man is amazingly complicated, not only that of the genius:   \
+but none is a \"miracle.\"— Whence, then, the belief that genius exists only in  \
+the artist, orator and philosopher? that only they have \"intuition\"? (Whereby  \
+they are supposed to possess a kind of miraculous eyeglass with which they can \
+see directly into \"the essence of the thing\"!) It is clear that people speak of\
+") _T("\
+genius only where the effects of the great intellect are most pleasant to them \
+and where they have no desire to feel envious. To call someone \"divine\" means: \
+\"here there is no need for us to compete.\" Then, everything finished and       \
+complete is regarded with admiration, everything still becoming is undervalued.\
+But no one can see in the work of the artist how it has become; that is its    \
+advantage, for wherever one can see the act of becoming one grows somewhat     \
+cool. The finished and perfect art of representation repulses all thinking as  \
+to how it has become; it tyrannizes as present completeness and perfection.    \
+That is why the masters of the art of representation count above all as gifted \
+with genius and why men of science do not. In reality, this evaluation of the  \
+former and undervaluation of the latter is only a piece of childishness in the \
+realm of reason.                                                               \
+                                                                               \
+                                                                               \
+163 The serious workman.— Do not talk about giftedness, inborn talents! One can\
+name great men of all kinds who were very little gifted. The acquired          \
+greatness, became \"geniuses\" (as we put it), through qualities the lack of     \
+which no one who knew what they were would boast of: they all possessed that   \
+seriousness of the efficient workman which first learns to construct the parts \
+properly before it ventures to fashion a great whole; they allowed themselves  \
+time for it, because they took more pleasure in making the little, secondary   \
+things well than in the effect of a dazzling whole. the recipe for becoming a  \
+good novelist, for example, is easy to give, but to carry it out presupposes   \
+qualities one is accustomed to overlook when one says \"I do not have enough    \
+talent.\" One has only to make a hundred or so sketches for novels, none longer \
+") _T("\
+than two pages but of such distinctness that every word in them is necessary;  \
+one should write down anecdotes each day until one has learned how to give them\
+the most pregnant and effective form; one should be tireless in collecting and \
+describing human types and characters; one should above all relate things to   \
+others and listen to others relate, keeping one's eyes and ears open for the   \
+effect produced on those present, one should travel like a landscape painter or\
+costume designer; one should excerpt for oneself out of the individual sciences\
+everything that will produce an artistic effect when it is well described, one \
+should, finally, reflect on the motives of human actions, disdain no signpost  \
+to instruction about them and be a collector of these things by day and night. \
+One should continue in this many-sided exercise some ten years: what is then   \
+created in the workshop, however, will be fit to go out into the world.— What, \
+however, do most people do? They begin, not with the parts, but with the whole.\
+Perhaps they chance to strike a right note, excite attention and from then on  \
+strike worse and worse notes, for good, natural reasons.— Sometimes, when the  \
+character and intellect needed to formulate such a life-plan are lacking, fate \
+and need take their place and lead the future master step by step through all  \
+the stipulations of his trade.                                                 \
+                                                                               \
+                                                                               \
+164 Peril and profit in the cult of the genius.— The belief in great, superior,\
+fruitful spirits is not necessarily, yet nonetheless is very frequently        \
+associated with that religious or semi-religious superstition that these       \
+spirits are of supra-human origin and possess certain miraculous abilities by  \
+virtue of which they acquire their knowledge by quite other means than the rest\
+") _T("\
+of mankind. One ascribes to them, it seems, a direct view of the nature of the \
+world, as it were a hole in the cloak of appearance, and believes that, by     \
+virtue of this miraculous seer's vision, they are able to communicate something\
+conclusive and decisive about man and the world without the toil and           \
+rigorousness required by science. As long as there continue to be those who    \
+believe in the miraculous in the domain of knowledge one can perhaps concede   \
+that these people themselves derive some benefit from their belief, inasmuch as\
+through their unconditional subjection to the great spirits they create for    \
+their own spirit during its time of development the finest form of discipline  \
+and schooling. On the other hand, it is at least questionable whether the      \
+superstitious belief in genius, in its privileges and special abilities, is of \
+benefit to the genius himself if it takes root in him. It is in any event a    \
+dangerous sign when a man is assailed by awe of himself, whether it be the     \
+celebrated Caesar's awe of Caesar or the awe of one's own genius now under     \
+consideration; when the sacrificial incense which is properly rendered only to \
+a god penetrates the brain of the genius, so that his head begins to swim and  \
+he comes to regard himself as something supra-human. The consequences that     \
+slowly result are: the feeling of irresponsibility, of exceptional rights, the \
+belief that he confers a favor by his mere presence, insane rage when anyone   \
+attempts even to compare him with others, let alone to rate him beneath them,  \
+or to draw attention to lapses in his work. Because he ceases to practice      \
+criticism of himself, at last one pinion after the other falls out of his      \
+plumage: that superstitious eats at the roots of his powers and perhaps even   \
+turns him into a hypocrite after his powers have fled from him. For the great  \
+spirits themselves it is therefore probably more beneficial if they acquire an \
+") _T("\
+insight into the nature and origin of their powers, if they grasp, that is to  \
+say, what purely human qualities have come together in them and what fortunate \
+circumstances attended them: in the first place undiminished energy, resolute  \
+application to individual goals, great personal courage, then the good fortune \
+to receive an upbringing which offered in the early years the finest teachers, \
+models and methods. To be sure, when their goal is the production of the       \
+greatest possible effect, unclarity with regard to oneself and that            \
+semi-insanity superadded to it has always achieved much; for what has been     \
+admired and envied at all times has been that power in them by virtue of which \
+they render men will-less and sweep them away into the delusion that the       \
+leaders they are following are supra-natural. Indeed, it elevates and inspires \
+men to believe that someone is in possession of supra-natural powers: to this  \
+extent Plato was right to say [Plato: Phaedrus, 244a] that madness has brought \
+the greatest of blessings upon mankind.— In rare individual cases this portion \
+of madness may, indeed, actually have been the means by which such a nature,   \
+excessive in all directions, was held firmly together: in the life of          \
+individuals, too, illusions that are in themselves poisons often play the role \
+of healers; yet, in the end, in the case of every \"genius\" who believes in his \
+own divinity the poison shows itself to the same degree as his \"genius\" grows  \
+old: one may recall, for example, the case of Napoleon, whose nature certainly \
+grew into the mighty unity that sets him apart from all men of modern times    \
+precisely through his belief in himself and his star and through the contempt  \
+for men that flowed from it; until in the end, however, this same belief went  \
+over into an almost insane fatalism, robbed him of his acuteness and swiftness \
+of perception, and became the cause of his destruction.                        \
+"); // -- Friedrich Nietzsche, "Human, All Too Human"
+

 	  	 
