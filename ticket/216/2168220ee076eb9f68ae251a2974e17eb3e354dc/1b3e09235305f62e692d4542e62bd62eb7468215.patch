Index: build/msw/makefile.vc
===================================================================
--- build/msw/makefile.vc	(revision 59882)
+++ build/msw/makefile.vc	(working copy)
@@ -1162,6 +1162,7 @@
 	$(OBJS)\auidll_floatpane.obj \
 	$(OBJS)\auidll_auibook.obj \
 	$(OBJS)\auidll_tabmdi.obj \
+	$(OBJS)\auidll_tabdocmdi.obj \
 	$(OBJS)\auidll_auibar.obj
 AUILIB_CXXFLAGS = /M$(__RUNTIME_LIBS_424)$(__DEBUGRUNTIME) /DWIN32 \
 	$(__DEBUGINFO) \
@@ -1180,6 +1181,7 @@
 	$(OBJS)\auilib_floatpane.obj \
 	$(OBJS)\auilib_auibook.obj \
 	$(OBJS)\auilib_tabmdi.obj \
+	$(OBJS)\auilib_tabdocmdi.obj \
 	$(OBJS)\auilib_auibar.obj
 RICHTEXTDLL_CXXFLAGS = /M$(__RUNTIME_LIBS_438)$(__DEBUGRUNTIME) /DWIN32 \
 	$(__DEBUGINFO) \
@@ -1474,6 +1476,7 @@
 	$(OBJS)\monodll_dockart.obj \
 	$(OBJS)\monodll_floatpane.obj \
 	$(OBJS)\monodll_auibook.obj \
+	$(OBJS)\monodll_tabdocmdi.obj \
 	$(OBJS)\monodll_tabmdi.obj \
 	$(OBJS)\monodll_auibar.obj \
 	$(OBJS)\monodll_richtextctrl.obj \
@@ -2098,6 +2101,7 @@
 	$(OBJS)\monolib_dockart.obj \
 	$(OBJS)\monolib_floatpane.obj \
 	$(OBJS)\monolib_auibook.obj \
+	$(OBJS)\monolib_tabdocmdi.obj \
 	$(OBJS)\monolib_tabmdi.obj \
 	$(OBJS)\monolib_auibar.obj \
 	$(OBJS)\monolib_richtextctrl.obj \
@@ -5595,6 +5599,9 @@
 $(OBJS)\monodll_auibook.obj: ..\..\src\aui\auibook.cpp
 	$(CXX) /c /nologo /TP /Fo$@ $(MONODLL_CXXFLAGS) ..\..\src\aui\auibook.cpp
 
+$(OBJS)\monodll_tabdocmdi.obj: ..\..\src\aui\tabdocmdi.cpp
+	$(CXX) /c /nologo /TP /Fo$@ $(MONODLL_CXXFLAGS) $**
+
 $(OBJS)\monodll_tabmdi.obj: ..\..\src\aui\tabmdi.cpp
 	$(CXX) /c /nologo /TP /Fo$@ $(MONODLL_CXXFLAGS) ..\..\src\aui\tabmdi.cpp
 
@@ -7598,6 +7605,9 @@
 $(OBJS)\monolib_auibook.obj: ..\..\src\aui\auibook.cpp
 	$(CXX) /c /nologo /TP /Fo$@ $(MONOLIB_CXXFLAGS) ..\..\src\aui\auibook.cpp
 
+$(OBJS)\monolib_tabdocmdi.obj: ..\..\src\aui\tabdocmdi.cpp
+	$(CXX) /c /nologo /TP /Fo$@ $(MONOLIB_CXXFLAGS) $**
+
 $(OBJS)\monolib_tabmdi.obj: ..\..\src\aui\tabmdi.cpp
 	$(CXX) /c /nologo /TP /Fo$@ $(MONOLIB_CXXFLAGS) ..\..\src\aui\tabmdi.cpp
 
@@ -12841,6 +12851,9 @@
 $(OBJS)\auidll_auibook.obj: ..\..\src\aui\auibook.cpp
 	$(CXX) /c /nologo /TP /Fo$@ $(AUIDLL_CXXFLAGS) ..\..\src\aui\auibook.cpp
 
+$(OBJS)\auidll_tabdocmdi.obj: ..\..\src\aui\tabdocmdi.cpp
+	$(CXX) /c /nologo /TP /Fo$@ $(AUIDLL_CXXFLAGS) $**
+
 $(OBJS)\auidll_tabmdi.obj: ..\..\src\aui\tabmdi.cpp
 	$(CXX) /c /nologo /TP /Fo$@ $(AUIDLL_CXXFLAGS) ..\..\src\aui\tabmdi.cpp
 
@@ -12862,6 +12875,9 @@
 $(OBJS)\auilib_auibook.obj: ..\..\src\aui\auibook.cpp
 	$(CXX) /c /nologo /TP /Fo$@ $(AUILIB_CXXFLAGS) ..\..\src\aui\auibook.cpp
 
+$(OBJS)\auilib_tabdocmdi.obj: ..\..\src\aui\tabdocmdi.cpp
+	$(CXX) /c /nologo /TP /Fo$@ $(AUILIB_CXXFLAGS) $**
+
 $(OBJS)\auilib_tabmdi.obj: ..\..\src\aui\tabmdi.cpp
 	$(CXX) /c /nologo /TP /Fo$@ $(AUILIB_CXXFLAGS) ..\..\src\aui\tabmdi.cpp
 
Index: build/msw/wx_aui.dsp
===================================================================
--- build/msw/wx_aui.dsp	(revision 59882)
+++ build/msw/wx_aui.dsp	(working copy)
@@ -998,6 +998,10 @@
 # End Source File
 # Begin Source File
 
+SOURCE=..\..\include\wx\aui\tabdocmdi.h
+# End Source File
+# Begin Source File
+
 SOURCE=..\..\include\wx\aui\tabmdi.h
 # End Source File
 # End Group
@@ -1026,9 +1030,14 @@
 # End Source File
 # Begin Source File
 
+SOURCE=..\..\src\aui\tabdocmdi.cpp
+# End Source File
+# Begin Source File
+
 SOURCE=..\..\src\aui\tabmdi.cpp
 # End Source File
 # End Group
 # End Target
 # End Project
 
+
Index: build/tools/build-wxwidgets.py
===================================================================
--- build/tools/build-wxwidgets.py	(revision 59882)
+++ build/tools/build-wxwidgets.py	(working copy)
@@ -1,385 +1,385 @@
-#!/usr/bin/env python
-
-###################################
-# Author: Kevin Ollivier
-# License: wxWidgets License
-###################################
-
-import os
-import re
-import sys
-import builder
-import commands
-import glob
-import optparse
-import platform
-import shutil
-import types
-
-# builder object
-wxBuilder = None
-
-scriptDir = os.path.abspath(sys.path[0])
-wxRootDir = os.path.abspath(os.path.join(scriptDir, "..", ".."))
-contribDir = os.path.join("contrib", "src")
-installDir = None
-
-if sys.platform.startswith("win"):
-    contribDir = os.path.join(wxRootDir, "contrib", "build")
-
-if sys.platform.startswith("win"):
-    toolkit = "msvc"
-else:
-    toolkit = "autoconf"
-
-option_dict = { 
-            "clean"     : (False, "Clean all files from the build directory"),
-            "debug"     : (False, "Build the library in debug symbols"),
-            "install"   : (False, "Install the toolkit to the installdir directory, or the default dir."),
-            "installdir" : (".", "Directory where built wxWidgets will be installed"),
-            "mac_universal_binary" : (False, "Build Mac version as a universal binary"),
-            "mac_lipo" : (False, "EXPERIMENTAL: Create a universal binary by merging a PPC and Intel build together."),
-            "mac_framework" : (False, "Install the Mac build as a framework"),
-            "no_config" : (False, "Turn off configure step on autoconf builds"),
-            "rebake"    : (False, "Regenerate Bakefile and autoconf files"),
-            "unicode"   : (False, "Build the library with unicode support"),
-            "wxpython"  : (False, "Build the wxWidgets library with all options needed by wxPython"),
-            "cocoa"     : (False, "Build the Cooca port (Mac only currently)."),
-            "osx_cocoa" : (False, "Build the new Cocoa port"),
-            "shared"    : (False, "Build wx as a dynamic library"),
-            "cairo"     : (False, "Build support for wxCairoContext (always true on GTK+)"),
-          }
-    
-parser = optparse.OptionParser(usage="usage: %prog [options]", version="%prog 1.0")
-
-for opt in option_dict:
-    default = option_dict[opt][0]
-    
-    action = "store"
-    if type(default) == types.BooleanType:
-        action = "store_true"
-    parser.add_option("--" + opt, default=default, action=action, dest=opt, help=option_dict[opt][1])
-
-options, arguments = parser.parse_args()
-
-def exitIfError(code, msg):
-    if code != 0:
-        print msg
+#!/usr/bin/env python
+
+###################################
+# Author: Kevin Ollivier
+# License: wxWidgets License
+###################################
+
+import os
+import re
+import sys
+import builder
+import commands
+import glob
+import optparse
+import platform
+import shutil
+import types
+
+# builder object
+wxBuilder = None
+
+scriptDir = os.path.abspath(sys.path[0])
+wxRootDir = os.path.abspath(os.path.join(scriptDir, "..", ".."))
+contribDir = os.path.join("contrib", "src")
+installDir = None
+
+if sys.platform.startswith("win"):
+    contribDir = os.path.join(wxRootDir, "contrib", "build")
+
+if sys.platform.startswith("win"):
+    toolkit = "msvc"
+else:
+    toolkit = "autoconf"
+
+option_dict = { 
+            "clean"     : (False, "Clean all files from the build directory"),
+            "debug"     : (False, "Build the library in debug symbols"),
+            "install"   : (False, "Install the toolkit to the installdir directory, or the default dir."),
+            "installdir" : (".", "Directory where built wxWidgets will be installed"),
+            "mac_universal_binary" : (False, "Build Mac version as a universal binary"),
+            "mac_lipo" : (False, "EXPERIMENTAL: Create a universal binary by merging a PPC and Intel build together."),
+            "mac_framework" : (False, "Install the Mac build as a framework"),
+            "no_config" : (False, "Turn off configure step on autoconf builds"),
+            "rebake"    : (False, "Regenerate Bakefile and autoconf files"),
+            "unicode"   : (False, "Build the library with unicode support"),
+            "wxpython"  : (False, "Build the wxWidgets library with all options needed by wxPython"),
+            "cocoa"     : (False, "Build the Cooca port (Mac only currently)."),
+            "osx_cocoa" : (False, "Build the new Cocoa port"),
+            "shared"    : (False, "Build wx as a dynamic library"),
+            "cairo"     : (False, "Build support for wxCairoContext (always true on GTK+)"),
+          }
+    
+parser = optparse.OptionParser(usage="usage: %prog [options]", version="%prog 1.0")
+
+for opt in option_dict:
+    default = option_dict[opt][0]
+    
+    action = "store"
+    if type(default) == types.BooleanType:
+        action = "store_true"
+    parser.add_option("--" + opt, default=default, action=action, dest=opt, help=option_dict[opt][1])
+
+options, arguments = parser.parse_args()
+
+def exitIfError(code, msg):
+    if code != 0:
+        print msg
         sys.exit(1)
-        
-def getWxRelease():
-    global wxRootDir
-    configureText = open(os.path.join(wxRootDir, "configure.in"), "r").read()
-    
-    majorVersion = re.search("wx_major_version_number=(\d)", configureText).group(1)
-    minorVersion = re.search("wx_minor_version_number=(\d)", configureText).group(1)
-    
-    return "%s.%s" % (majorVersion, minorVersion)
-        
-def doMacLipoBuild(arch, buildDir, installDir, cxxcompiler="g++-4.0", cccompiler="gcc-4.0", target="10.4", flags=""):
-    # PPC build
-    archInstallDir = installDir + "/" + arch
-    os.environ["CXX"] = "%s -arch %s %s" % (cxxcompiler, arch, flags)
-    os.environ["CC"] = "%s -arch %s %s" % (cccompiler, arch, flags)
-    os.environ["MACOSX_DEPLOYMENT_TARGET"] = target
-    archArgs = ["prefix=" + archInstallDir]
-    buildRoot = "bld-" + arch
-    if buildDir:
-        buildRoot = buildDir + "/" + buildRoot
-    
-    if not os.path.exists(buildRoot):
-        os.makedirs(buildRoot)
-    
-    olddir = os.getcwd()
-    os.chdir(buildRoot)
-    
-    if not options.no_config:
+        
+def getWxRelease():
+    global wxRootDir
+    configureText = open(os.path.join(wxRootDir, "configure.in"), "r").read()
+    
+    majorVersion = re.search("wx_major_version_number=(\d)", configureText).group(1)
+    minorVersion = re.search("wx_minor_version_number=(\d)", configureText).group(1)
+    
+    return "%s.%s" % (majorVersion, minorVersion)
+        
+def doMacLipoBuild(arch, buildDir, installDir, cxxcompiler="g++-4.0", cccompiler="gcc-4.0", target="10.4", flags=""):
+    # PPC build
+    archInstallDir = installDir + "/" + arch
+    os.environ["CXX"] = "%s -arch %s %s" % (cxxcompiler, arch, flags)
+    os.environ["CC"] = "%s -arch %s %s" % (cccompiler, arch, flags)
+    os.environ["MACOSX_DEPLOYMENT_TARGET"] = target
+    archArgs = ["prefix=" + archInstallDir]
+    buildRoot = "bld-" + arch
+    if buildDir:
+        buildRoot = buildDir + "/" + buildRoot
+    
+    if not os.path.exists(buildRoot):
+        os.makedirs(buildRoot)
+    
+    olddir = os.getcwd()
+    os.chdir(buildRoot)
+    
+    if not options.no_config:
         exitIfError(wxBuilder.configure(options=configure_opts), "Error running configure")
-    exitIfError(wxBuilder.build(options=archArgs), "Error building")
-    exitIfError(wxBuilder.install(options=["prefix=" + archInstallDir]), "Error Installing")
-    
-    if options.wxpython and os.path.exists(os.path.join(wxRootDir, contribDir)):
-        exitIfError(wxBuilder.build(dir=os.path.join(contribDir, "gizmos"), options=archArgs), "Error building gizmos")
-        exitIfError(wxBuilder.install(os.path.join(contribDir, "gizmos"), options=["prefix=" + archInstallDir]), "Error Installing gizmos")
-        
-        exitIfError(wxBuilder.build(dir=os.path.join(contribDir, "stc"),options=archArgs), "Error building stc")
-        exitIfError(wxBuilder.install(os.path.join(contribDir, "stc"),options=["prefix=" + archInstallDir]), "Error installing stc")
-
-    os.chdir(olddir)
-    
-# compiler / build system specific args
-buildDir = None
-args = None
-installDir = options.installdir
-
-if toolkit == "autoconf":
-    configure_opts = []
-    
-    if options.unicode:
-        configure_opts.append("--enable-unicode")
-        
-    if options.debug:
-        configure_opts.append("--enable-debug")
-        
-    if options.mac_universal_binary: 
-        configure_opts.append("--enable-universal_binary")
-        
-    if options.cocoa:
-        configure_opts.append("--with-cocoa")
-        
-    if options.osx_cocoa:
-        configure_opts.append("--with-osx_cocoa")
-    
-    wxpy_configure_opts = [
-                        "--with-opengl",
-                        "--enable-sound",
-                        "--with-sdl",
-                        "--with-gnomeprint",
-                        "--enable-graphics_ctx",
-                        "--enable-mediactrl",
-                        "--enable-display",
-                        "--enable-geometry",
-                        "--enable-debug_flag",
-                        "--enable-optimise",
-                        "--disable-debugreport",
-                        "--enable-monolithic"
-                        ]
-                        
-    if not options.mac_framework and options.installdir != option_dict["installdir"][0]:
-        configure_opts.append("--prefix=" + installDir)
-
-    if options.wxpython:
-        configure_opts.extend(wxpy_configure_opts)
-
-    if options.rebake:
-        retval = os.system("make -f autogen.mk")
-        exitIfError(retval, "Error running autogen.mk")
-        
-    if options.mac_framework:
+    exitIfError(wxBuilder.build(options=archArgs), "Error building")
+    exitIfError(wxBuilder.install(options=["prefix=" + archInstallDir]), "Error Installing")
+    
+    if options.wxpython and os.path.exists(os.path.join(wxRootDir, contribDir)):
+        exitIfError(wxBuilder.build(dir=os.path.join(contribDir, "gizmos"), options=archArgs), "Error building gizmos")
+        exitIfError(wxBuilder.install(os.path.join(contribDir, "gizmos"), options=["prefix=" + archInstallDir]), "Error Installing gizmos")
+        
+        exitIfError(wxBuilder.build(dir=os.path.join(contribDir, "stc"),options=archArgs), "Error building stc")
+        exitIfError(wxBuilder.install(os.path.join(contribDir, "stc"),options=["prefix=" + archInstallDir]), "Error installing stc")
+
+    os.chdir(olddir)
+    
+# compiler / build system specific args
+buildDir = None
+args = None
+installDir = options.installdir
+
+if toolkit == "autoconf":
+    configure_opts = []
+    
+    if options.unicode:
+        configure_opts.append("--enable-unicode")
+        
+    if options.debug:
+        configure_opts.append("--enable-debug")
+        
+    if options.mac_universal_binary: 
+        configure_opts.append("--enable-universal_binary")
+        
+    if options.cocoa:
+        configure_opts.append("--with-cocoa")
+        
+    if options.osx_cocoa:
+        configure_opts.append("--with-osx_cocoa")
+    
+    wxpy_configure_opts = [
+                        "--with-opengl",
+                        "--enable-sound",
+                        "--with-sdl",
+                        "--with-gnomeprint",
+                        "--enable-graphics_ctx",
+                        "--enable-mediactrl",
+                        "--enable-display",
+                        "--enable-geometry",
+                        "--enable-debug_flag",
+                        "--enable-optimise",
+                        "--disable-debugreport",
+                        "--enable-monolithic"
+                        ]
+                        
+    if not options.mac_framework and options.installdir != option_dict["installdir"][0]:
+        configure_opts.append("--prefix=" + installDir)
+
+    if options.wxpython:
+        configure_opts.extend(wxpy_configure_opts)
+
+    if options.rebake:
+        retval = os.system("make -f autogen.mk")
+        exitIfError(retval, "Error running autogen.mk")
+        
+    if options.mac_framework:
         # Framework build is always a universal binary
         options.mac_lipo = True
         name = "wx"
         if options.osx_cocoa:
             name += "OSXCocoa"
         installDir = "/Library/Frameworks/%s.framework/Versions/%s" % (name, getWxRelease())
-        configure_opts.append("--prefix=" + installDir)
-        # framework builds always need to be monolithic
-        if not "--enable-monolithic" in configure_opts:
-            configure_opts.append("--enable-monolithic")
-        
-    print "Configure options: " + `configure_opts`
-    wxBuilder = builder.AutoconfBuilder()
-    if not options.no_config and not options.clean and not options.mac_lipo:
-        exitIfError(wxBuilder.configure(options=configure_opts), "Error running configure")
-
-elif toolkit in ["msvc", "msvcProject"]:
-    flags = {}
-    buildDir = os.path.join(scriptDir, "..", "msw")
-
-    if options.unicode:
-        flags["wxUSE_UNICODE"] = "1"
-        flags["wxUSE_UNICODE_MSLU"] = "1"
-
-    if options.cairo:
-        flags["wxUSE_CAIRO"] = "1"
-
-    if options.wxpython:
-        flags["wxDIALOG_UNIT_COMPATIBILITY "] = "0"
-        flags["wxUSE_DEBUG_CONTEXT"] = "1"
-        flags["wxUSE_MEMORY_TRACING"] = "1"
-        flags["wxUSE_DIALUP_MANAGER"] = "0"
-        flags["wxUSE_GLCANVAS"] = "1"
-        flags["wxUSE_POSTSCRIPT"] = "1"
-        flags["wxUSE_AFM_FOR_POSTSCRIPT"] = "0"
-        flags["wxUSE_DISPLAY"] = "1"
-        flags["wxUSE_DIB_FOR_BITMAP"] = "1"
-        flags["wxUSE_DEBUGREPORT"] = "0"
-        flags["wxUSE_GRAPHICS_CONTEXT"] = "1"
-        flags["wxUSE_DATEPICKCTRL_GENERIC"] = "1"
-    
-        # setup the wxPython 'hybrid' build
-        if not options.debug:
-            flags["wxUSE_MEMORY_TRACING"] = "0"
-            flags["wxUSE_DEBUG_CONTEXT"] = "0"
-
-    mswIncludeDir = os.path.join(wxRootDir, "include", "wx", "msw")
-    setup0File = os.path.join(mswIncludeDir, "setup0.h")
-    setupText = open(setup0File, "rb").read()
-    
-    for flag in flags:
-        setupText, subsMade = re.subn(flag + "\s+?\d", "%s %s" % (flag, flags[flag]), setupText)
-        if subsMade == 0:
-            print "Flag %s wasn't found!" % flag
-            sys.exit(1)
-
-    setupFile = open(os.path.join(mswIncludeDir, "setup.h"), "wb")
-    setupFile.write(setupText)
-    setupFile.close()
-    args = []
-    if toolkit == "msvc":
+        configure_opts.append("--prefix=" + installDir)
+        # framework builds always need to be monolithic
+        if not "--enable-monolithic" in configure_opts:
+            configure_opts.append("--enable-monolithic")
+        
+    print "Configure options: " + `configure_opts`
+    wxBuilder = builder.AutoconfBuilder()
+    if not options.no_config and not options.clean and not options.mac_lipo:
+        exitIfError(wxBuilder.configure(options=configure_opts), "Error running configure")
+
+elif toolkit in ["msvc", "msvcProject"]:
+    flags = {}
+    buildDir = os.path.join(scriptDir, "..", "msw")
+
+    if options.unicode:
+        flags["wxUSE_UNICODE"] = "1"
+        flags["wxUSE_UNICODE_MSLU"] = "1"
+
+    if options.cairo:
+        flags["wxUSE_CAIRO"] = "1"
+
+    if options.wxpython:
+        flags["wxDIALOG_UNIT_COMPATIBILITY "] = "0"
+        flags["wxUSE_DEBUG_CONTEXT"] = "1"
+        flags["wxUSE_MEMORY_TRACING"] = "1"
+        flags["wxUSE_DIALUP_MANAGER"] = "0"
+        flags["wxUSE_GLCANVAS"] = "1"
+        flags["wxUSE_POSTSCRIPT"] = "1"
+        flags["wxUSE_AFM_FOR_POSTSCRIPT"] = "0"
+        flags["wxUSE_DISPLAY"] = "1"
+        flags["wxUSE_DIB_FOR_BITMAP"] = "1"
+        flags["wxUSE_DEBUGREPORT"] = "0"
+        flags["wxUSE_GRAPHICS_CONTEXT"] = "1"
+        flags["wxUSE_DATEPICKCTRL_GENERIC"] = "1"
+    
+        # setup the wxPython 'hybrid' build
+        if not options.debug:
+            flags["wxUSE_MEMORY_TRACING"] = "0"
+            flags["wxUSE_DEBUG_CONTEXT"] = "0"
+
+    mswIncludeDir = os.path.join(wxRootDir, "include", "wx", "msw")
+    setup0File = os.path.join(mswIncludeDir, "setup0.h")
+    setupText = open(setup0File, "rb").read()
+    
+    for flag in flags:
+        setupText, subsMade = re.subn(flag + "\s+?\d", "%s %s" % (flag, flags[flag]), setupText)
+        if subsMade == 0:
+            print "Flag %s wasn't found!" % flag
+            sys.exit(1)
+
+    setupFile = open(os.path.join(mswIncludeDir, "setup.h"), "wb")
+    setupFile.write(setupText)
+    setupFile.close()
+    args = []
+    if toolkit == "msvc":
         print "setting build options..."
-        args.append("-f makefile.vc")
-        if options.unicode:
-            args.append("UNICODE=1")
-            args.append("MSLU=1")
-
-        if options.wxpython:
-            args.append("OFFICIAL_BUILD=1")
-            args.append("SHARED=1")
-            args.append("MONOLITHIC=0")
-            args.append("USE_OPENGL=1")
-            args.append("USE_GDIPLUS=1")
-            
-            if not options.debug:
-                args.append("DEBUG_FLAG=1")
-                args.append("CXXFLAGS=/D__NO_VC_CRTDBG__")
-                args.append("WXDEBUGFLAG=h")
-                args.append("BUILD=release")
-
-        wxBuilder = builder.MSVCBuilder()
-        
-    if toolkit == "msvcProject":
-        args = []
-        if options.shared or options.wxpython:
-            args.append("wx_dll.dsw")
-        else:
-            args.append("wx.dsw")
-            
-        # TODO:
-        wxBuilder = builder.MSVCProjectBuilder()
-    
-if not wxBuilder:
-    print "Builder not available for your specified platform/compiler."
-    sys.exit(1)
-
-if options.clean:
-    print "Performing cleanup."
-    wxBuilder.clean()
-    
-    if options.wxpython:
-        exitIfError(wxBuilder.clean(os.path.join(contribDir, "gizmos")), "Error building gizmos")
-        exitIfError(wxBuilder.clean(os.path.join(contribDir, "stc")), "Error building stc")
-    
-    sys.exit(0)
-
-isLipo = False    
-if options.mac_lipo:
-    if options.mac_universal_binary:
-        print "WARNING: Cannot specify both mac_lipo and mac_universal_binary, as they conflict."
-        print "         Using mac_universal_binary..."
-    else:
-        isLipo = True
-        # TODO: Add 64-bit when we're building OS X Cocoa
-        
-        # 2.8, use gcc 3.3 on PPC for 10.3 support...
-        macVersion = platform.mac_ver()[0]
-        isLeopard = macVersion.find("10.5") != -1
-        
-        if not isLeopard and os.path.exists(os.path.join(wxRootDir, contribDir)):
-            doMacLipoBuild("ppc", buildDir, installDir, cxxcompiler="g++-3.3", cccompiler="gcc-3.3", 
-                        target="10.3", flags="-DMAC_OS_X_VERSION_MAX_ALLOWED=1040")
-        else:
-            doMacLipoBuild("ppc", buildDir, installDir)
-
-        doMacLipoBuild("i386", buildDir, installDir)
-
-        result = os.system("python %s/distrib/scripts/mac/lipo-dir.py %s %s %s" % (wxRootDir, installDir + "/ppc", installDir + "/i386", installDir))
-        fname = os.path.abspath(installDir + '/bin/wx-config') 
-        data = open(fname).read()
-        data = data.replace('ppc/', '')
-        data = data.replace('i386/', '')
-        open(fname, 'w').write(data)
-        
-        shutil.rmtree(installDir + "/ppc")
-        shutil.rmtree(installDir + "/i386")
-  
-if not isLipo:
-    exitIfError(wxBuilder.build(dir=buildDir, options=args), "Error building")
-    
-    if options.wxpython and os.path.exists(contribDir):
-        exitIfError(wxBuilder.build(os.path.join(contribDir, "gizmos"), options=args), "Error building gizmos")
-        exitIfError(wxBuilder.build(os.path.join(contribDir, "stc"),options=args), "Error building stc")
-        
-    if options.install:
-        wxBuilder.install()
-        
-        if options.wxpython and os.path.exists(contribDir):
-            exitIfError(wxBuilder.install(os.path.join(contribDir, "gizmos")), "Error building gizmos")
-            exitIfError(wxBuilder.install(os.path.join(contribDir, "stc")), "Error building stc")
-        
-if options.mac_framework:
-
-    def renameLibrary(libname, frameworkname):
-        reallib = libname
-        links = []
-        while os.path.islink(reallib):
-            links.append(reallib)
-            reallib = "lib/" + os.readlink(reallib)
-            
-        print "reallib is %s" % reallib
-        os.system("mv -f %s lib/%s.dylib" % (reallib, frameworkname))
-        
-        for link in links:
-            os.system("ln -s -f %s.dylib %s" % (frameworkname, link))
-
-    os.chdir(installDir)
-    build_string = ""
-    if options.debug:
-        build_string = "d"
-    version = commands.getoutput("bin/wx-config --release")
-    basename = commands.getoutput("bin/wx-config --basename")
-    configname = commands.getoutput("bin/wx-config --selected-config")
-    
-    os.system("ln -s -f bin Resources")
-    
-    # we make wx the "actual" library file and link to it from libwhatever.dylib
-    # so that things can link to wx and survive minor version changes
-    renameLibrary("lib/lib%s-%s.dylib" % (basename, version), "wx")
-    os.system("ln -s -f lib/wx.dylib wx")
-    
-    os.system("ln -s -f include/wx Headers")
-    
-    for lib in ["GL", "STC", "Gizmos", "Gizmos_xrc"]:  
-        libfile = "lib/lib%s_%s-%s.dylib" % (basename, lib.lower(), version)
-        if os.path.exists(libfile):
-            frameworkDir = "framework/wx%s/%s" % (lib, version)
-            if not os.path.exists(frameworkDir):
-                os.makedirs(frameworkDir)
-            renameLibrary(libfile, "wx" + lib)
-            os.system("ln -s -f ../../../%s %s/wx%s" % (libfile, frameworkDir, lib))        
-    
-    for lib in glob.glob("lib/*.dylib"):
-        if not os.path.islink(lib):
-            corelibname = "lib/lib%s-%s.0.dylib" % (basename, version)
-            os.system("install_name_tool -id %s %s" % (os.path.join(installDir, lib), lib))
-            os.system("install_name_tool -change %s %s %s" % (os.path.join(installDir, "i386", corelibname), os.path.join(installDir, corelibname), lib))
-            
-    os.chdir("include")
-    
-    header_template = """
-    
-#ifndef __WX_FRAMEWORK_HEADER__
-#define __WX_FRAMEWORK_HEADER__
-
-%s
-
-#endif // __WX_FRAMEWORK_HEADER__
-"""
-    headers = ""
-    header_dir = "wx-%s/wx" % version
-    for include in glob.glob(header_dir + "/*.h"):
-        headers += "wx/" + os.path.basename(include) + "\n"
-        
-    framework_header = open("wx.h", "w")
-    framework_header.write(header_template % headers)
-    framework_header.close()
-    
-    os.system("ln -s -f %s wx" % header_dir)
-    os.system("ln -s -f ../../../lib/wx/include/%s/wx/setup.h wx/setup.h" % configname)
-    
-    os.chdir(os.path.join(installDir, "..", ".."))
-    os.system("ln -s -f %s Versions/Current" % os.path.basename(installDir))
-    os.system("ln -s -f Versions/Current/Headers Headers")
-    os.system("ln -s -f Versions/Current/Resources Resources")
-    os.system("ln -s -f Versions/Current/wx wx")
-    
+        args.append("-f makefile.vc")
+        if options.unicode:
+            args.append("UNICODE=1")
+            args.append("MSLU=1")
+
+        if options.wxpython:
+            args.append("OFFICIAL_BUILD=1")
+            args.append("SHARED=1")
+            args.append("MONOLITHIC=0")
+            args.append("USE_OPENGL=1")
+            args.append("USE_GDIPLUS=1")
+            
+            if not options.debug:
+                args.append("DEBUG_FLAG=1")
+                args.append("CXXFLAGS=/D__NO_VC_CRTDBG__")
+                args.append("WXDEBUGFLAG=h")
+                args.append("BUILD=release")
+
+        wxBuilder = builder.MSVCBuilder()
+        
+    if toolkit == "msvcProject":
+        args = []
+        if options.shared or options.wxpython:
+            args.append("wx_dll.dsw")
+        else:
+            args.append("wx.dsw")
+            
+        # TODO:
+        wxBuilder = builder.MSVCProjectBuilder()
+    
+if not wxBuilder:
+    print "Builder not available for your specified platform/compiler."
+    sys.exit(1)
+
+if options.clean:
+    print "Performing cleanup."
+    wxBuilder.clean()
+    
+    if options.wxpython:
+        exitIfError(wxBuilder.clean(os.path.join(contribDir, "gizmos")), "Error building gizmos")
+        exitIfError(wxBuilder.clean(os.path.join(contribDir, "stc")), "Error building stc")
+    
+    sys.exit(0)
+
+isLipo = False    
+if options.mac_lipo:
+    if options.mac_universal_binary:
+        print "WARNING: Cannot specify both mac_lipo and mac_universal_binary, as they conflict."
+        print "         Using mac_universal_binary..."
+    else:
+        isLipo = True
+        # TODO: Add 64-bit when we're building OS X Cocoa
+        
+        # 2.8, use gcc 3.3 on PPC for 10.3 support...
+        macVersion = platform.mac_ver()[0]
+        isLeopard = macVersion.find("10.5") != -1
+        
+        if not isLeopard and os.path.exists(os.path.join(wxRootDir, contribDir)):
+            doMacLipoBuild("ppc", buildDir, installDir, cxxcompiler="g++-3.3", cccompiler="gcc-3.3", 
+                        target="10.3", flags="-DMAC_OS_X_VERSION_MAX_ALLOWED=1040")
+        else:
+            doMacLipoBuild("ppc", buildDir, installDir)
+
+        doMacLipoBuild("i386", buildDir, installDir)
+
+        result = os.system("python %s/distrib/scripts/mac/lipo-dir.py %s %s %s" % (wxRootDir, installDir + "/ppc", installDir + "/i386", installDir))
+        fname = os.path.abspath(installDir + '/bin/wx-config') 
+        data = open(fname).read()
+        data = data.replace('ppc/', '')
+        data = data.replace('i386/', '')
+        open(fname, 'w').write(data)
+        
+        shutil.rmtree(installDir + "/ppc")
+        shutil.rmtree(installDir + "/i386")
+  
+if not isLipo:
+    exitIfError(wxBuilder.build(dir=buildDir, options=args), "Error building")
+    
+    if options.wxpython and os.path.exists(contribDir):
+        exitIfError(wxBuilder.build(os.path.join(contribDir, "gizmos"), options=args), "Error building gizmos")
+        exitIfError(wxBuilder.build(os.path.join(contribDir, "stc"),options=args), "Error building stc")
+        
+    if options.install:
+        wxBuilder.install()
+        
+        if options.wxpython and os.path.exists(contribDir):
+            exitIfError(wxBuilder.install(os.path.join(contribDir, "gizmos")), "Error building gizmos")
+            exitIfError(wxBuilder.install(os.path.join(contribDir, "stc")), "Error building stc")
+        
+if options.mac_framework:
+
+    def renameLibrary(libname, frameworkname):
+        reallib = libname
+        links = []
+        while os.path.islink(reallib):
+            links.append(reallib)
+            reallib = "lib/" + os.readlink(reallib)
+            
+        print "reallib is %s" % reallib
+        os.system("mv -f %s lib/%s.dylib" % (reallib, frameworkname))
+        
+        for link in links:
+            os.system("ln -s -f %s.dylib %s" % (frameworkname, link))
+
+    os.chdir(installDir)
+    build_string = ""
+    if options.debug:
+        build_string = "d"
+    version = commands.getoutput("bin/wx-config --release")
+    basename = commands.getoutput("bin/wx-config --basename")
+    configname = commands.getoutput("bin/wx-config --selected-config")
+    
+    os.system("ln -s -f bin Resources")
+    
+    # we make wx the "actual" library file and link to it from libwhatever.dylib
+    # so that things can link to wx and survive minor version changes
+    renameLibrary("lib/lib%s-%s.dylib" % (basename, version), "wx")
+    os.system("ln -s -f lib/wx.dylib wx")
+    
+    os.system("ln -s -f include/wx Headers")
+    
+    for lib in ["GL", "STC", "Gizmos", "Gizmos_xrc"]:  
+        libfile = "lib/lib%s_%s-%s.dylib" % (basename, lib.lower(), version)
+        if os.path.exists(libfile):
+            frameworkDir = "framework/wx%s/%s" % (lib, version)
+            if not os.path.exists(frameworkDir):
+                os.makedirs(frameworkDir)
+            renameLibrary(libfile, "wx" + lib)
+            os.system("ln -s -f ../../../%s %s/wx%s" % (libfile, frameworkDir, lib))        
+    
+    for lib in glob.glob("lib/*.dylib"):
+        if not os.path.islink(lib):
+            corelibname = "lib/lib%s-%s.0.dylib" % (basename, version)
+            os.system("install_name_tool -id %s %s" % (os.path.join(installDir, lib), lib))
+            os.system("install_name_tool -change %s %s %s" % (os.path.join(installDir, "i386", corelibname), os.path.join(installDir, corelibname), lib))
+            
+    os.chdir("include")
+    
+    header_template = """
+    
+#ifndef __WX_FRAMEWORK_HEADER__
+#define __WX_FRAMEWORK_HEADER__
+
+%s
+
+#endif // __WX_FRAMEWORK_HEADER__
+"""
+    headers = ""
+    header_dir = "wx-%s/wx" % version
+    for include in glob.glob(header_dir + "/*.h"):
+        headers += "wx/" + os.path.basename(include) + "\n"
+        
+    framework_header = open("wx.h", "w")
+    framework_header.write(header_template % headers)
+    framework_header.close()
+    
+    os.system("ln -s -f %s wx" % header_dir)
+    os.system("ln -s -f ../../../lib/wx/include/%s/wx/setup.h wx/setup.h" % configname)
+    
+    os.chdir(os.path.join(installDir, "..", ".."))
+    os.system("ln -s -f %s Versions/Current" % os.path.basename(installDir))
+    os.system("ln -s -f Versions/Current/Headers Headers")
+    os.system("ln -s -f Versions/Current/Resources Resources")
+    os.system("ln -s -f Versions/Current/wx wx")
+    
Index: build/tools/builder.py
===================================================================
--- build/tools/builder.py	(revision 59882)
+++ build/tools/builder.py	(working copy)
@@ -1,223 +1,223 @@
-import os
-import string
-import subprocess
-import sys
-import time
-
-class BuildError(Exception):
-    def __init__(self, value):
-        self.value = value
-        
-    def __repr__(self):
-        return repr(self.value)
-
-def runInDir(command, dir=None):
-    if dir:
-        olddir = os.getcwd()
-        os.chdir(dir)
-
-    commandStr = string.join(command, " ")
-    result = os.system(commandStr)
-
-    if dir:
-        os.chdir(olddir)
-        
-    return result
-
-class Builder:
-    """
-    Base class exposing the Builder interface.
-    """
-    
-    def __init__(self, formatName="", commandName="", programDir=None):
-        """
-        formatName = human readable name for project format (should correspond with Bakefile names)
-        commandName = name of command line program used to invoke builder
-        programDir = directory program is located in, if not on the path
-        """
-        
-        self.dir = dir
-        self.name = commandName
-        self.formatName = formatName
-        self.programDir = programDir
-        self.doSetup()
-        
-    def doSetup(self):
-        """
-        Do anything special needed to configure the environment to build with this builder.
-        """
-        
-        pass
-
-    def isAvailable(self):
-        """
-        Run sanity checks before attempting to build with this format
-        """
-        # Make sure the builder program exists
-        programPath = self.getProgramPath()
-        if os.path.exists(programPath):
-            return True
-        else:
-            # check the PATH for the program
-            # TODO: How do we check if we're in Cygwin?
-            if sys.platform.startswith("win"):
-                result = os.system(self.name)
-                if result == 0:
-                    return True
-                dirs = os.environ["PATH"].split(":")
-                
-                for dir in dirs:
-                    if os.path.isfile(os.path.join(dir, self.name)):
-                        return True  
-            
-            else:
-                result = os.system("which %s" % self.name)
-        
-                if result == 0:
-                    return True
-            
-        return False
-        
-    def getProgramPath(self):
-        if self.programDir:
-            path = os.path.join(self.programDir, self.name)
-            if sys.platform.startswith("win"):
-                path = '"%s"' % path
-            return path
-        else:
-            return self.name
-        
-    def clean(self, dir=None, projectFile=None):
-        """
-        dir = the directory containing the project file
-        projectFile = Some formats need to explicitly specify the project file's name
-        """
-        if self.isAvailable():
-            result = runInDir("%s clean" % self.getProgramPath(), dir)
-            return result
-            
-        return False
-        
-    def configure(self, options=None):
-        # if we don't have configure, just report success
-        return True
-            
-    def build(self, dir=None, projectFile=None, targets=None, options=None):
-        if self.isAvailable():
-            if options:
-                print "Options %r" % string.join(options, " ")
-                optionList = list(options)
-            else:
-            	optionList = []
-
-            optionList.insert(0, self.getProgramPath())
-            
-            result = runInDir(optionList, dir)
-
-            return result
-        
+import os
+import string
+import subprocess
+import sys
+import time
+
+class BuildError(Exception):
+    def __init__(self, value):
+        self.value = value
+        
+    def __repr__(self):
+        return repr(self.value)
+
+def runInDir(command, dir=None):
+    if dir:
+        olddir = os.getcwd()
+        os.chdir(dir)
+
+    commandStr = string.join(command, " ")
+    result = os.system(commandStr)
+
+    if dir:
+        os.chdir(olddir)
+        
+    return result
+
+class Builder:
+    """
+    Base class exposing the Builder interface.
+    """
+    
+    def __init__(self, formatName="", commandName="", programDir=None):
+        """
+        formatName = human readable name for project format (should correspond with Bakefile names)
+        commandName = name of command line program used to invoke builder
+        programDir = directory program is located in, if not on the path
+        """
+        
+        self.dir = dir
+        self.name = commandName
+        self.formatName = formatName
+        self.programDir = programDir
+        self.doSetup()
+        
+    def doSetup(self):
+        """
+        Do anything special needed to configure the environment to build with this builder.
+        """
+        
+        pass
+
+    def isAvailable(self):
+        """
+        Run sanity checks before attempting to build with this format
+        """
+        # Make sure the builder program exists
+        programPath = self.getProgramPath()
+        if os.path.exists(programPath):
+            return True
+        else:
+            # check the PATH for the program
+            # TODO: How do we check if we're in Cygwin?
+            if sys.platform.startswith("win"):
+                result = os.system(self.name)
+                if result == 0:
+                    return True
+                dirs = os.environ["PATH"].split(":")
+                
+                for dir in dirs:
+                    if os.path.isfile(os.path.join(dir, self.name)):
+                        return True  
+            
+            else:
+                result = os.system("which %s" % self.name)
+        
+                if result == 0:
+                    return True
+            
+        return False
+        
+    def getProgramPath(self):
+        if self.programDir:
+            path = os.path.join(self.programDir, self.name)
+            if sys.platform.startswith("win"):
+                path = '"%s"' % path
+            return path
+        else:
+            return self.name
+        
+    def clean(self, dir=None, projectFile=None):
+        """
+        dir = the directory containing the project file
+        projectFile = Some formats need to explicitly specify the project file's name
+        """
+        if self.isAvailable():
+            result = runInDir("%s clean" % self.getProgramPath(), dir)
+            return result
+            
+        return False
+        
+    def configure(self, options=None):
+        # if we don't have configure, just report success
+        return True
+            
+    def build(self, dir=None, projectFile=None, targets=None, options=None):
+        if self.isAvailable():
+            if options:
+                print "Options %r" % string.join(options, " ")
+                optionList = list(options)
+            else:
+            	optionList = []
+
+            optionList.insert(0, self.getProgramPath())
+            
+            result = runInDir(optionList, dir)
+
+            return result
+        
         return 1
-
-    def install(self, dir=None, options=None):
-        if self.isAvailable():
-            
-            args = ["make", "install"]
-            if options:
-            	args.extend(options)
-            result = runInDir(args, dir)
-            return result
-            
+
+    def install(self, dir=None, options=None):
+        if self.isAvailable():
+            
+            args = ["make", "install"]
+            if options:
+            	args.extend(options)
+            result = runInDir(args, dir)
+            return result
+            
         return 1
-
-# Concrete subclasses of abstract Builder interface
-
-class GNUMakeBuilder(Builder):
-    def __init__(self, commandName="make", formatName="GNUMake"):
-        Builder.__init__(self, commandName=commandName, formatName=formatName)
-        
-
-class XCodeBuilder(Builder):
-    def __init__(self, commandName="xcodebuild", formatName="XCode"):
-        Builder.__init__(self, commandName=commandName, formatName=formatName)
-
-        
-class AutoconfBuilder(GNUMakeBuilder):
-    def __init__(self, formatName="autoconf"):
-        GNUMakeBuilder.__init__(self, formatName=formatName)
-        
-    def configure(self, dir=None, options=None):
-        #olddir = os.getcwd()
-        #os.chdir(dir)
-        
-        configdir = dir
-        if not dir:
-            configdir = os.getcwd()
-        
-        configure_cmd = ""
-        while os.path.exists(configdir):
-            config_cmd = os.path.join(configdir, "configure")
-            if not os.path.exists(config_cmd):
-                parentdir = os.path.abspath(os.path.join(configdir, ".."))
-                if configdir == parentdir:
-                    break
-                
-                configdir = parentdir 
-            else:
-                configure_cmd = config_cmd
-                break
-                
-        if not configure_cmd:
+
+# Concrete subclasses of abstract Builder interface
+
+class GNUMakeBuilder(Builder):
+    def __init__(self, commandName="make", formatName="GNUMake"):
+        Builder.__init__(self, commandName=commandName, formatName=formatName)
+        
+
+class XCodeBuilder(Builder):
+    def __init__(self, commandName="xcodebuild", formatName="XCode"):
+        Builder.__init__(self, commandName=commandName, formatName=formatName)
+
+        
+class AutoconfBuilder(GNUMakeBuilder):
+    def __init__(self, formatName="autoconf"):
+        GNUMakeBuilder.__init__(self, formatName=formatName)
+        
+    def configure(self, dir=None, options=None):
+        #olddir = os.getcwd()
+        #os.chdir(dir)
+        
+        configdir = dir
+        if not dir:
+            configdir = os.getcwd()
+        
+        configure_cmd = ""
+        while os.path.exists(configdir):
+            config_cmd = os.path.join(configdir, "configure")
+            if not os.path.exists(config_cmd):
+                parentdir = os.path.abspath(os.path.join(configdir, ".."))
+                if configdir == parentdir:
+                    break
+                
+                configdir = parentdir 
+            else:
+                configure_cmd = config_cmd
+                break
+                
+        if not configure_cmd:
             sys.stderr.write("Could not find configure script at %r. Have you run autoconf?\n" % dir)
             return 1
-        
-        optionsStr = string.join(options, " ") if options else ""
-        result = os.system("%s %s" % (configure_cmd, optionsStr))
-        #os.chdir(olddir)
-        return result
-        
-
-class MSVCBuilder(Builder):
-    def __init__(self):
-        Builder.__init__(self, commandName="nmake", formatName="msvc")
-        
-    def isAvailable(self):
-        return os.system("%s /help" % self.name) == 0
-
-class MSVCProjectBuilder(Builder):
-    def __init__(self):
-        Builder.__init__(self, commandName="VCExpress.exe", formatName="msvcProject")
-        for key in ["VS90COMNTOOLS", "VC80COMNTOOLS", "VC71COMNTOOLS"]:
-            if os.environ.has_key(key):
-                self.prgoramDir = os.path.join(os.environ[key], "..", "IDE")
-                
-        if self.programDir == None:
-            for version in ["9.0", "8", ".NET 2003"]:
-                msvcDir = "C:\\Program Files\\Microsoft Visual Studio %s\\Common7\\IDE" % version
-                if os.path.exists(msvcDir):
-                    self.programDir = msvcDir
-
-    def isAvailable(self):
-        if self.programDir:
-            path = os.path.join(self.programDir, self.name)
-            if os.path.exists(path):
-                return True
-            else:
-                # I don't have commercial versions of MSVC so I can't test this
-                name = "devenv.com"
-                path = os.path.join(self.programDir, name)
-                if os.path.exists(path):
-                    self.name = "devenv.com"
-                    return True
-        
-        return False
-
-builders = [GNUMakeBuilder, XCodeBuilder, AutoconfBuilder, MSVCBuilder, MSVCProjectBuilder]
-
-def getAvailableBuilders():
-    availableBuilders = {}
-    for symbol in builders:
-        thisBuilder = symbol()
-        if thisBuilder.isAvailable():
-            availableBuilders[thisBuilder.formatName] = symbol
-                
-    return availableBuilders
+        
+        optionsStr = string.join(options, " ") if options else ""
+        result = os.system("%s %s" % (configure_cmd, optionsStr))
+        #os.chdir(olddir)
+        return result
+        
+
+class MSVCBuilder(Builder):
+    def __init__(self):
+        Builder.__init__(self, commandName="nmake", formatName="msvc")
+        
+    def isAvailable(self):
+        return os.system("%s /help" % self.name) == 0
+
+class MSVCProjectBuilder(Builder):
+    def __init__(self):
+        Builder.__init__(self, commandName="VCExpress.exe", formatName="msvcProject")
+        for key in ["VS90COMNTOOLS", "VC80COMNTOOLS", "VC71COMNTOOLS"]:
+            if os.environ.has_key(key):
+                self.prgoramDir = os.path.join(os.environ[key], "..", "IDE")
+                
+        if self.programDir == None:
+            for version in ["9.0", "8", ".NET 2003"]:
+                msvcDir = "C:\\Program Files\\Microsoft Visual Studio %s\\Common7\\IDE" % version
+                if os.path.exists(msvcDir):
+                    self.programDir = msvcDir
+
+    def isAvailable(self):
+        if self.programDir:
+            path = os.path.join(self.programDir, self.name)
+            if os.path.exists(path):
+                return True
+            else:
+                # I don't have commercial versions of MSVC so I can't test this
+                name = "devenv.com"
+                path = os.path.join(self.programDir, name)
+                if os.path.exists(path):
+                    self.name = "devenv.com"
+                    return True
+        
+        return False
+
+builders = [GNUMakeBuilder, XCodeBuilder, AutoconfBuilder, MSVCBuilder, MSVCProjectBuilder]
+
+def getAvailableBuilders():
+    availableBuilders = {}
+    for symbol in builders:
+        thisBuilder = symbol()
+        if thisBuilder.isAvailable():
+            availableBuilders[thisBuilder.formatName] = symbol
+                
+    return availableBuilders
Index: docs/latex/wx/auidocmdich.tex
===================================================================
--- docs/latex/wx/auidocmdich.tex	(revision 0)
+++ docs/latex/wx/auidocmdich.tex	(revision 0)
@@ -0,0 +1,103 @@
+\section{\class{wxAuiDocMDIChildFrame}}\label{wxauidocmdichildframe}
+
+wxAuiDocMDIParentFrame is part of the wxAUI class framework.
+See also \helpref{wxAUI overview}{wxauioverview}.
+The wxAuiDocMDIChildFrame class provides a default frame for displaying documents
+on separate windows. This class can only be used for wxAUI MDI child frames.
+
+The class is part of the document/view framework supported by wxWidgets,
+and cooperates with the \helpref{wxView}{wxview}, \helpref{wxDocument}{wxdocument},
+\rtfsp\helpref{wxDocManager}{wxdocmanager} and \helpref{wxDocTemplate}{wxdoctemplate} classes.
+
+See the example application in {\tt samples/auidocvwmdi}.
+
+\wxheading{Derived from}
+
+\helpref{wxAuiMDIChildFrame}{wxauimdichildframe}\\
+\helpref{wxPanel}{wxpanel}\\
+\helpref{wxWindow}{wxwindow}\\
+\helpref{wxEvtHandler}{wxevthandler}\\
+\helpref{wxObject}{wxobject}
+
+\wxheading{Include files}
+
+<wx/aui/tabdocmdi.h>
+
+\wxheading{See also}
+
+\helpref{Document/view overview}{docviewoverview}, \helpref{wxAuiMDIChildFrame}{wxauimdichildframe}
+
+\membersection{wxAuiDocMDIChildFrame::m\_childDocument}\label{wxauidocmdichildframemchilddocument}
+
+\member{wxDocument*}{m\_childDocument}
+
+The document associated with the frame.
+
+\membersection{wxAuiDocMDIChildFrame::m\_childView}\label{wxauidocmdichildframemchildview}
+
+\member{wxView*}{m\_childView}
+
+The view associated with the frame.
+
+\membersection{wxAuiDocMDIChildFrame::wxAuiDocMDIChildFrame}\label{wxauidocmdichildframector}
+
+\func{}{wxAuiDocMDIChildFrame}{\void}
+\func{}{wxAuiDocMDIChildFrame}{\param{wxDocument* }{doc}, \param{wxView* }{view}, \param{wxAuiDocMDIParentFrame* }{parent},
+ \param{wxWindowID}{ winid}, \param{const wxString\& }{title}, \param{const wxPoint\&}{ pos = wxDefaultPosition},
+ \param{const wxSize\&}{ size = wxDefaultSize},
+ \param{long}{ style = wxDEFAULT\_FRAME\_STYLE}, \param{const wxString\& }{name = wxFrameNameStr}}
+
+Constructor.
+
+\membersection{wxAuiDocMDIChildFrame::\destruct{wxAuiDocMDIChildFrame}}\label{wxauidocmdichildframedtor}
+
+\func{}{\destruct{wxAuiDocMDIChildFrame}}{\void}
+
+Destructor.
+
+\func{bool}{Create}{\param{wxDocument* }{doc}, \param{wxView* }{view}, \param{wxAuiDocMDIParentFrame* }{parent},
+ \param{wxWindowID}{ winid}, \param{const wxString\& }{title}, \param{const wxPoint\&}{ pos = wxDefaultPosition},
+ \param{const wxSize\&}{ size = wxDefaultSize},
+ \param{long}{ style = wxDEFAULT\_FRAME\_STYLE}, \param{const wxString\& }{name = wxFrameNameStr}}
+
+Creates the window.
+
+\membersection{wxAuiDocMDIChildFrame::GetDocument}\label{wxauidocmdichildframegetdocument}
+
+\constfunc{wxDocument*}{GetDocument}{\void}
+
+Returns the document associated with this frame.
+
+\membersection{wxAuiDocMDIChildFrame::GetView}\label{wxauidocmdichildframegetview}
+
+\constfunc{wxView*}{GetView}{\void}
+
+Returns the view associated with this frame.
+
+\membersection{wxAuiDocMDIChildFrame::OnActivate}\label{wxauidocmdichildframeonactivate}
+
+\func{void}{OnActivate}{\param{wxActivateEvent\&}{ event}}
+
+Sets the currently active view to be the frame's view. You may need
+to override (but still call) this function in order to set the keyboard
+focus for your subwindow.
+
+\membersection{wxAuiDocMDIChildFrame::OnCloseWindow}\label{wxauidocmdichildframeonclosewindow}
+
+\func{void}{OnCloseWindow}{\param{wxCloseEvent\&}{ event}}
+
+Closes and deletes the current view and document.
+
+\membersection{wxAuiDocMDIChildFrame::SetDocument}\label{wxauidocmdichildframesetdocument}
+
+\func{void}{SetDocument}{\param{wxDocument* }{doc}}
+
+Sets the document for this frame.
+
+\membersection{wxAuiDocMDIChildFrame::SetView}\label{wxauidocmdichildframesetview}
+
+\func{void}{SetView}{\param{wxView* }{view}}
+
+Sets the view for this frame.
+
+
Index: docs/latex/wx/auidocmdipr.tex
===================================================================
--- docs/latex/wx/auidocmdipr.tex	(revision 0)
+++ docs/latex/wx/auidocmdipr.tex	(revision 0)
@@ -0,0 +1,77 @@
+\section{\class{wxAuiDocMDIParentFrame}}\label{wxauidocmdiparentframe}
+
+wxAuiDocMDIParentFrame is part of the wxAUI class framework.
+See also \helpref{wxAUI overview}{wxauioverview}.
+The wxAuiDocMDIParentFrame class provides a default top-level frame for
+applications using the document/view framework. This class can only be used for wxAUI MDI parent frames.
+
+It cooperates with the \helpref{wxView}{wxview}, \helpref{wxDocument}{wxdocument},
+\rtfsp\helpref{wxDocManager}{wxdocmanager} and \helpref{wxDocTemplates}{wxdoctemplate} classes.
+
+See the example application in {\tt samples/auidocvwmdi}.
+
+\wxheading{Derived from}
+
+\helpref{wxAuiMDIParentFrame}{wxauimdiparentframe}\\
+\helpref{wxFrame}{wxframe}\\
+\helpref{wxWindow}{wxwindow}\\
+\helpref{wxEvtHandler}{wxevthandler}\\
+\helpref{wxObject}{wxobject}
+
+\wxheading{Include files}
+
+<wx/aui/tabdocmdi.h>
+
+\wxheading{See also}
+
+\helpref{Document/view overview}{docviewoverview}, \helpref{wxAuiMDIParentFrame}{wxauimdiparentframe}
+
+\latexignore{\rtfignore{\wxheading{Members}}}
+
+\membersection{wxAuiDocMDIParentFrame::wxAuiDocMDIParentFrame}\label{wxauidocmdiparentframector}
+
+\func{}{wxAuiDocMDIParentFrame}{\void}
+\func{}{wxAuiDocMDIParentFrame}{\param{wxDocManager* }{manager}, \param{wxWindow* }{parent}, \param{wxWindowID}{ winid},
+ \param{const wxString\& }{title}, \param{const wxPoint\&}{ pos = wxDefaultPosition},
+ \param{const wxSize\&}{ size = wxDefaultSize},
+ \param{long}{ style = wxDEFAULT\_FRAME\_STYLE | wxVSCROLL | wxHSCROLL}, \param{const wxString\& }{name = wxFrameNameStr}}
+
+Constructor.
+
+\membersection{wxAuiDocMDIParentFrame::\destruct{wxAuiDocMDIParentFrame}}\label{wxauidocmdiparentframedtor}
+
+\func{}{\destruct{wxAuiDocMDIParentFrame}}{\void}
+
+Destructor.
+
+\membersection{wxAuiDocMDIParentFrame::Create}\label{wxauidocmdiparentframecreate}
+
+\func{bool}{Create}{\param{wxDocManager* }{manager}, \param{wxWindow* }{parent}, \param{wxWindowID}{ winid},
+ \param{const wxString\& }{title}, \param{const wxPoint\&}{ pos = wxDefaultPosition},
+ \param{const wxSize\&}{ size = wxDefaultSize},
+ \param{long}{ style = wxDEFAULT\_FRAME\_STYLE | wxVSCROLL | wxHSCROLL}, \param{const wxString\& }{name = wxFrameNameStr}}
+
+Creates the window.
+
+\membersection{wxAuiDocMDIParentFrame::OnCloseWindow}\label{wxauidocmdiparentframeonclosewindow}
+
+\func{void}{OnCloseWindow}{\param{wxCloseEvent\&}{ event}}
+
+Deletes all views and documents. If no user input cancelled the
+operation, the frame will be destroyed and the application will exit.
+
+Since understanding how document/view clean-up takes place can be difficult,
+the implementation of this function is shown below.
+
+\begin{verbatim}
+void wxDocParentFrame::OnCloseWindow(wxCloseEvent& event)
+{
+  if (m_docManager->Clear(!event.CanVeto()))
+  {
+    this->Destroy();
+  }
+  else
+    event.Veto();
+}
+\end{verbatim}
+
Index: docs/latex/wx/classes.tex
===================================================================
--- docs/latex/wx/classes.tex	(revision 59882)
+++ docs/latex/wx/classes.tex	(working copy)
@@ -21,6 +21,8 @@
 \input artprov.tex
 \input auidockart.tex
 \input auitabart.tex
+\input auidocmdich.tex
+\input auidocmdipr.tex
 \input auimanager.tex
 \input auinotebook.tex
 \input auipaneinfo.tex
Index: include/wx/aui/aui.h
===================================================================
--- include/wx/aui/aui.h	(revision 59882)
+++ include/wx/aui/aui.h	(working copy)
@@ -18,6 +18,8 @@
 #include "wx/aui/auibar.h"
 #include "wx/aui/auibook.h"
 #include "wx/aui/tabmdi.h"
+#include "wx/aui/tabdocmdi.h"
 
 #endif // _WX_AUI_H_
 
+
Index: include/wx/aui/tabdocmdi.h
===================================================================
--- include/wx/aui/tabdocmdi.h	(revision 0)
+++ include/wx/aui/tabdocmdi.h	(revision 0)
@@ -0,0 +1,167 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        tabdocmdi.h
+// Purpose:     Frame classes for Aui MDI document/view applications
+// Author:      Julian Smart
+// Modified by: Kinaou Herv
+// Created:     01/02/97
+// RCS-ID:      $Id:$
+// Copyright:   (c) Julian Smart
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_AUITABDOCMDI_H_
+#define _WX_AUITABDOCMDI_H_
+
+#if wxUSE_AUI
+
+#include "wx/docview.h"
+#include "wx/aui/tabmdi.h"
+
+//-----------------------------------------------------------------------------
+// classes
+//-----------------------------------------------------------------------------
+
+
+/*
+ * Use this instead of wxAuiMDIParentFrame
+ */
+
+class wxAuiDocMDIChildFrame;
+class WXDLLIMPEXP_AUI wxAuiDocMDIParentFrame: public wxAuiMDIParentFrame
+{
+public:
+    wxAuiDocMDIParentFrame();
+    wxAuiDocMDIParentFrame(wxDocManager *manager,
+                           wxWindow *parent,
+                           wxWindowID winid,
+                           const wxString& title,
+                           const wxPoint& pos = wxDefaultPosition,
+                           const wxSize& size = wxDefaultSize,
+                           long style = wxDEFAULT_FRAME_STYLE | wxVSCROLL | wxHSCROLL,
+                           const wxString& name = wxFrameNameStr);
+
+    virtual ~wxAuiDocMDIParentFrame();
+
+    bool Create(wxDocManager *manager,
+                wxWindow *parent,
+                wxWindowID winid,
+                const wxString& title,
+                const wxPoint& pos = wxDefaultPosition,
+                const wxSize& size = wxDefaultSize,
+                long style = wxDEFAULT_FRAME_STYLE | wxVSCROLL | wxHSCROLL,
+                const wxString& name = wxFrameNameStr );
+
+    // Extend event processing to search the document manager's event table
+    virtual bool ProcessEvent(wxEvent& event);
+
+    wxDocManager *GetDocumentManager(void) const { return m_docManager; }
+
+    void OnNotebookPageChanged(wxAuiNotebookEvent &event);
+    void OnExit(wxCommandEvent& event);
+    void OnMRUFile(wxCommandEvent& event);
+    void OnCloseWindow(wxCloseEvent& event);
+
+protected:
+    void Init();
+    wxDocManager *m_docManager;
+
+public:
+    void SetArtProvider(wxAuiTabArt* provider);
+    wxAuiTabArt* GetArtProvider();
+    wxAuiNotebook* GetNotebook() const;
+    
+#if wxUSE_MENUS
+    wxMenu* GetWindowMenu() const { return m_pWindowMenu; }
+    void SetWindowMenu(wxMenu* pMenu);
+#endif // wxUSE_MENUS
+
+    void SetChildMenuBar(wxAuiDocMDIChildFrame *pChild);
+
+    wxAuiDocMDIChildFrame *GetActiveChild() const;
+    void SetActiveChild(wxAuiDocMDIChildFrame* pChildFrame);
+
+    wxAuiMDIClientWindow *GetClientWindow() const;
+
+#if wxUSE_MENUS
+    void RemoveWindowMenu(wxMenuBar *pMenuBar);
+    void AddWindowMenu(wxMenuBar *pMenuBar);
+    void DoHandleMenu(wxCommandEvent &event);
+#endif // wxUSE_MENUS
+
+
+private:
+    DECLARE_EVENT_TABLE()
+    DECLARE_DYNAMIC_CLASS(wxAuiDocMDIParentFrame)
+};
+
+/*
+ * Use this instead of wxAuiDocMDIChildFrame
+ */
+
+class WXDLLIMPEXP_AUI wxAuiDocMDIChildFrame: public wxAuiMDIChildFrame
+{
+public:
+    wxAuiDocMDIChildFrame();
+    wxAuiDocMDIChildFrame(wxDocument *doc,
+                          wxView *view,
+                          wxAuiDocMDIParentFrame *parent,
+                          wxWindowID winid,
+                          const wxString& title,
+                          const wxPoint& pos = wxDefaultPosition,
+                          const wxSize& size = wxDefaultSize,
+                          long style = wxDEFAULT_FRAME_STYLE,
+                          const wxString& name = wxFrameNameStr);
+
+    virtual ~wxAuiDocMDIChildFrame();
+
+    bool Create(wxDocument *doc,
+                wxView *view,
+                wxAuiDocMDIParentFrame *parent,
+                wxWindowID winid,
+                const wxString& title,
+                const wxPoint& pos = wxDefaultPosition,
+                const wxSize& size = wxDefaultSize,
+                long style = wxDEFAULT_FRAME_STYLE,
+                const wxString& name = wxFrameNameStr);
+
+    // Extend event processing to search the view's event table
+    virtual bool ProcessEvent(wxEvent& event);
+
+    inline wxDocument *GetDocument() const { return m_childDocument; }
+    inline wxView *GetView(void) const { return m_childView; }
+    inline void SetDocument(wxDocument *doc) { m_childDocument = doc; }
+    inline void SetView(wxView *view) { m_childView = view; }
+    bool Destroy() { m_childView = (wxView *)NULL; return wxAuiMDIChildFrame::Destroy(); }
+
+protected:
+    void Init();
+    wxDocument*       m_childDocument;
+    wxView*           m_childView;
+
+public:
+    void OnMenuHighlight(wxMenuEvent& event);
+    void OnActivate(wxActivateEvent& event);
+    void OnCloseWindow(wxCloseEvent& event);
+
+    void SetMDIParentFrame(wxAuiDocMDIParentFrame* parent);
+    wxAuiDocMDIParentFrame* GetMDIParentFrame() const;
+    
+public:
+    // This function needs to be called when a size change is confirmed,
+    // we needed this function to prevent anybody from the outside
+    // changing the panel... it messes the UI layout when we would allow it.
+    void ApplyMDIChildFrameRect();
+    void DoShow(bool show);
+
+private:
+    DECLARE_DYNAMIC_CLASS(wxAuiDocMDIChildFrame)
+    DECLARE_EVENT_TABLE()
+
+    friend class wxAuiMDIClientWindow;
+};
+
+#endif
+    // wxUSE_AUI
+
+#endif
+    // _WX_AUITABDOCMDI_H_
Index: src/aui/tabdocmdi.cpp
===================================================================
--- src/aui/tabdocmdi.cpp	(revision 0)
+++ src/aui/tabdocmdi.cpp	(revision 0)
@@ -0,0 +1,380 @@
+/////////////////////////////////////////////////////////////////////////////
+// Name:        tabdocmdi.cpp
+// Purpose:     Frame classes for MDI document/view applications
+// Author:      Julian Smart
+// Modified by: Kinaou Herv
+// Created:     01/02/97
+// RCS-ID:      $Id:$
+// Copyright:   (c) Julian Smart
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+// For compilers that support precompilation, includes "wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+  #pragma hdrstop
+#endif
+
+#if wxUSE_AUI
+#if wxUSE_MDI
+
+#include "wx/aui/tabdocmdi.h"
+
+enum MDI_MENU_ID
+{
+    wxWINDOWCLOSE = 4001,
+    wxWINDOWCLOSEALL,
+    wxWINDOWNEXT,
+    wxWINDOWPREV
+};
+
+/*
+ * Docview Aui MDI parent frame
+ */
+
+IMPLEMENT_DYNAMIC_CLASS(wxAuiDocMDIParentFrame, wxAuiMDIParentFrame)
+
+BEGIN_EVENT_TABLE(wxAuiDocMDIParentFrame, wxAuiMDIParentFrame)
+#if wxUSE_MENUS
+    EVT_MENU(wxID_ANY, wxAuiDocMDIParentFrame::DoHandleMenu)
+#endif
+    EVT_MENU(wxID_EXIT, wxAuiDocMDIParentFrame::OnExit)
+    EVT_MENU_RANGE(wxID_FILE1, wxID_FILE9, wxAuiDocMDIParentFrame::OnMRUFile)
+    EVT_CLOSE(wxAuiDocMDIParentFrame::OnCloseWindow)
+END_EVENT_TABLE()
+
+wxAuiDocMDIParentFrame::wxAuiDocMDIParentFrame()
+{
+    Init();
+}
+
+wxAuiDocMDIParentFrame::wxAuiDocMDIParentFrame(wxDocManager *manager,
+    wxWindow *parent, wxWindowID winid, const wxString& title,
+    const wxPoint& pos, const wxSize& size, long style, const wxString& name)
+{
+    Init();
+    Create(manager, parent, winid, title, pos, size, style, name);
+}
+
+wxAuiDocMDIParentFrame::~wxAuiDocMDIParentFrame()
+{}
+
+bool wxAuiDocMDIParentFrame::Create(wxDocManager *manager,
+    wxWindow *parent, wxWindowID winid, const wxString& title,
+    const wxPoint& pos, const wxSize& size, long style, const wxString& name)
+{
+    m_docManager = manager;
+    if (wxAuiMDIParentFrame::Create(parent, winid, title, pos, size, style, name))
+    {
+        GetNotebook()->Connect(GetNotebook()->GetId(),
+                               wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGED,
+                               wxAuiNotebookEventHandler(wxAuiDocMDIParentFrame::OnNotebookPageChanged),
+                               NULL,
+                               this);
+        return true;
+    }
+    return false;
+}
+
+void wxAuiDocMDIParentFrame::OnExit(wxCommandEvent& WXUNUSED(event))
+{
+    Close();
+}
+
+void wxAuiDocMDIParentFrame::Init()
+{
+    wxAuiMDIParentFrame::Init();
+    m_docManager = NULL;
+}
+
+void wxAuiDocMDIParentFrame::OnMRUFile(wxCommandEvent& event)
+{
+    wxString f(m_docManager->GetHistoryFile(event.GetId() - wxID_FILE1));
+    if (!f.empty())
+        (void)m_docManager->CreateDocument(f, wxDOC_SILENT);
+}
+
+// Extend event processing to search the view's event table
+bool wxAuiDocMDIParentFrame::ProcessEvent(wxEvent& event)
+{
+    // Try the document manager, then do default processing
+    if (!m_docManager || !m_docManager->ProcessEvent(event))
+    {
+#if wxUSE_MENUS
+        // Catch the events of kind wxID_CLOSE[_ALL] to send the appropriate tabmdi event
+        if (event.GetEventType() == wxEVT_COMMAND_MENU_SELECTED)
+        {
+            if (event.GetId() == wxID_CLOSE)
+                event.SetId(wxWINDOWCLOSE);
+            else if (event.GetId() == wxID_CLOSE_ALL)
+                event.SetId(wxWINDOWCLOSEALL);
+        }
+#endif //wxUSE_MENUS
+        return wxAuiMDIParentFrame::ProcessEvent(event);
+    }
+    else
+        return true;
+}
+
+void wxAuiDocMDIParentFrame::OnNotebookPageChanged(wxAuiNotebookEvent &event)
+{
+    wxWindow *selWnd = GetNotebook()->GetPage(GetNotebook()->GetSelection());
+    if (selWnd->IsKindOf(CLASSINFO(wxAuiDocMDIChildFrame)))
+    {
+        wxAuiDocMDIChildFrame *selFrm = wxDynamicCast(selWnd, wxAuiDocMDIChildFrame);
+        if (selFrm->GetView())
+            selFrm->GetView()->Activate(true);
+    }
+    event.Skip(true);
+}
+
+void wxAuiDocMDIParentFrame::OnCloseWindow(wxCloseEvent& event)
+{
+    wxCommandEvent eventCloseAll(wxEVT_COMMAND_MENU_SELECTED, wxWINDOWCLOSEALL);
+    eventCloseAll.Skip();
+    DoHandleMenu(eventCloseAll);
+
+    if (eventCloseAll.GetSkipped())
+    {
+        GetNotebook()->Disconnect(GetNotebook()->GetId(),
+                                  wxEVT_COMMAND_AUINOTEBOOK_PAGE_CHANGED,
+                                  wxAuiNotebookEventHandler(wxAuiDocMDIParentFrame::OnNotebookPageChanged),
+                                  NULL,
+                                  this);
+        this->Destroy();
+    }
+    else
+        event.Veto();
+}
+
+void wxAuiDocMDIParentFrame::SetArtProvider(wxAuiTabArt* provider)
+{
+    wxAuiMDIParentFrame::SetArtProvider(provider);
+}
+
+wxAuiTabArt* wxAuiDocMDIParentFrame::GetArtProvider()
+{
+    return wxAuiMDIParentFrame::GetArtProvider();
+}
+
+wxAuiNotebook* wxAuiDocMDIParentFrame::GetNotebook() const
+{
+    return wxAuiMDIParentFrame::GetNotebook();
+}
+
+#if wxUSE_MENUS
+void wxAuiDocMDIParentFrame::SetWindowMenu(wxMenu* pMenu)
+{
+    wxAuiMDIParentFrame::SetWindowMenu(pMenu);
+}
+#endif // wxUSE_MENUS
+
+void wxAuiDocMDIParentFrame::SetChildMenuBar(wxAuiDocMDIChildFrame* pChild)
+{
+    wxAuiMDIParentFrame::SetChildMenuBar(wxDynamicCast(pChild, wxAuiMDIChildFrame));
+}
+
+wxAuiDocMDIChildFrame *wxAuiDocMDIParentFrame::GetActiveChild() const
+{
+    return wxDynamicCast(wxAuiMDIParentFrame::GetActiveChild(), wxAuiDocMDIChildFrame);
+}
+
+void wxAuiDocMDIParentFrame::SetActiveChild(wxAuiDocMDIChildFrame* pChildFrame)
+{
+    wxAuiMDIParentFrame::SetActiveChild(wxDynamicCast(pChildFrame, wxAuiMDIChildFrame));
+}
+
+wxAuiMDIClientWindow *wxAuiDocMDIParentFrame::GetClientWindow() const
+{
+    return wxAuiMDIParentFrame::GetClientWindow();
+}
+
+#if wxUSE_MENUS
+void wxAuiDocMDIParentFrame::RemoveWindowMenu(wxMenuBar* pMenuBar)
+{
+    wxAuiMDIParentFrame::RemoveWindowMenu(pMenuBar);
+}
+
+void wxAuiDocMDIParentFrame::AddWindowMenu(wxMenuBar *pMenuBar)
+{
+    wxAuiMDIParentFrame::AddWindowMenu(pMenuBar);
+}
+
+void wxAuiDocMDIParentFrame::DoHandleMenu(wxCommandEvent& event)
+{
+    switch (event.GetId())
+    {
+    case wxWINDOWCLOSEALL:
+        while (m_pActiveChild)
+        {
+            if (!m_pActiveChild->Close())
+            {
+                event.Skip(false);
+                return; // failure
+            }
+        }
+        break;
+    default:
+        wxAuiMDIParentFrame::DoHandleMenu(event);
+    }
+}
+#endif // wxUSE_MENUS
+
+
+/*
+ * Default document child frame for Aui MDI children
+ */
+
+IMPLEMENT_DYNAMIC_CLASS(wxAuiDocMDIChildFrame, wxAuiMDIChildFrame)
+
+BEGIN_EVENT_TABLE(wxAuiDocMDIChildFrame, wxAuiMDIChildFrame)
+    EVT_MENU_HIGHLIGHT_ALL(wxAuiDocMDIChildFrame::OnMenuHighlight)
+    EVT_ACTIVATE(wxAuiDocMDIChildFrame::OnActivate)
+    EVT_CLOSE(wxAuiDocMDIChildFrame::OnCloseWindow)
+END_EVENT_TABLE()
+
+void wxAuiDocMDIChildFrame::Init()
+{
+    wxAuiMDIChildFrame::Init();
+    m_childDocument = (wxDocument*)  NULL;
+    m_childView = (wxView*) NULL;
+}
+
+wxAuiDocMDIChildFrame::wxAuiDocMDIChildFrame()
+{
+    Init();
+}
+
+wxAuiDocMDIChildFrame::wxAuiDocMDIChildFrame(wxDocument *doc, wxView *view,
+    wxAuiDocMDIParentFrame *parent, wxWindowID winid, const wxString& title,
+    const wxPoint& WXUNUSED(pos), const wxSize& size, long style, const wxString& name)
+{
+    Init();
+    
+    // There are two ways to create an tabbed mdi child fram without
+    // making it the active document.  Either Show(false) can be called
+    // before Create() (as is customary on some ports with wxFrame-type
+    // windows), or wxMINIMIZE can be passed in the style flags.  Note that
+    // wxAuiMDIChildFrame is not really derived from wxFrame, as wxMDIChildFrame
+    // is, but those are the expected symantics.  No style flag is passed
+    // onto the panel underneath.
+    if (style & wxMINIMIZE)
+        m_activate_on_create = false;
+        
+    Create(doc, view, parent, winid, title, wxDefaultPosition, size, 0, name);
+}
+
+bool wxAuiDocMDIChildFrame::Create(wxDocument *doc, wxView *view,
+    wxAuiDocMDIParentFrame *parent, wxWindowID winid, const wxString& title,
+    const wxPoint& pos, const wxSize& size, long style, const wxString& name)
+{
+    m_childDocument = doc;
+    m_childView = view;
+    if (wxAuiMDIChildFrame::Create(wxDynamicCast(parent, wxAuiMDIParentFrame),
+        winid, title, pos, size, style, name))
+    {
+        if (view)
+            view->SetFrame(this);
+        return true;
+    }
+
+    return false;
+}
+
+wxAuiDocMDIChildFrame::~wxAuiDocMDIChildFrame()
+{
+    m_childView = (wxView *) NULL;
+}
+
+// Extend event processing to search the view's event table
+bool wxAuiDocMDIChildFrame::ProcessEvent(wxEvent& event)
+{
+    static wxEvent *ActiveEvent = NULL;
+
+    // Break recursion loops
+    if (ActiveEvent == &event)
+        return false;
+
+    ActiveEvent = &event;
+
+    bool ret;
+    if ( !m_childView || ! m_childView->ProcessEvent(event) )
+    {
+        // Only hand up to the parent if it's a menu command
+        if (!event.IsKindOf(CLASSINFO(wxCommandEvent)) || !GetParent() || !GetParent()->ProcessEvent(event))
+            ret = wxEvtHandler::ProcessEvent(event);
+        else
+            ret = true;
+    }
+    else
+        ret = true;
+
+    ActiveEvent = NULL;
+    return ret;
+}
+
+void wxAuiDocMDIChildFrame::OnMenuHighlight(wxMenuEvent& event)
+{
+    wxAuiMDIChildFrame::OnMenuHighlight(event);
+}
+
+void wxAuiDocMDIChildFrame::OnActivate(wxActivateEvent& event)
+{
+    wxAuiMDIChildFrame::OnActivate(event);
+
+    if (event.GetActive() && m_childView)
+        m_childView->Activate(event.GetActive());
+}
+
+void wxAuiDocMDIChildFrame::OnCloseWindow(wxCloseEvent& event)
+{
+    // Close view but don't delete the frame while doing so!
+    // ...since it will be deleted by wxWidgets if we return true.
+    if (m_childView)
+    {
+        bool ans = event.CanVeto()
+            ? m_childView->Close(false) // false means don't delete associated window
+            : true; // Must delete.
+
+        if (ans)
+        {
+            m_childView->Activate(false);
+            delete m_childView;
+            m_childView = (wxView *) NULL;
+            m_childDocument = (wxDocument *) NULL;
+
+            wxAuiMDIChildFrame::OnCloseWindow(event);
+        }
+        else
+            event.Veto();
+    }
+    else
+        event.Veto();
+}
+
+void wxAuiDocMDIChildFrame::SetMDIParentFrame(wxAuiDocMDIParentFrame* parentFrame)
+{
+    wxAuiMDIChildFrame::SetMDIParentFrame(wxDynamicCast(parentFrame, wxAuiMDIParentFrame));
+}
+
+wxAuiDocMDIParentFrame* wxAuiDocMDIChildFrame::GetMDIParentFrame() const
+{
+    return wxDynamicCast(wxAuiMDIChildFrame::GetMDIParentFrame(), wxAuiDocMDIParentFrame);
+}
+
+void wxAuiDocMDIChildFrame::ApplyMDIChildFrameRect()
+{
+    wxAuiMDIChildFrame::ApplyMDIChildFrameRect();
+}
+
+void wxAuiDocMDIChildFrame::DoShow(bool show)
+{
+    wxAuiMDIChildFrame::DoShow(show);
+}
+
+#endif
+    //wxUSE_AUI
+#endif
+    // wxUSE_MDI
+
